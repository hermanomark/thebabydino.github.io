<!DOCTYPE html>
<html lang='en'>
	<head>
		<meta charset='UTF-8' />
		<title>SVGrr</title>
		<link rel='stylesheet' href='styles/index.processed.css'>
	</head>
	<body>
		<h1>behind fillet.js - round poly(gon|line) corners</h1>

		<p>I've recently felt frustrated at the lack of an option to round the corners of a <code>&lt;polygon&gt;</code> element by simply specifying a rounding radius (<code>r</code>) attribute. After all, the <code>&lt;rect&gt;</code> element gives us the option of specifying rounding radii along the <code><var>x</var></code> and <code><var>y</var></code> axes via the <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rx'><code>rx</code></a> and <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ry'><code>ry</code></a> attributes.</p>

		<p>I've learned that it's been proposed and got asked if I could draft an algorithm for getting the equivalent <code>&lt;path&gt;</code> data (<code>d</code>) attribute from the <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/points'><code>points</code></a> and <code>r</code> attributes specified for the initial <code>&lt;polygon&gt;</code>. I've never done this before, had no idea how to do it, what to begin with, so I'd thought I'd have a more clear idea once I've coded some kind of JavaScript polyfill.</p>
		
		<p>Well, here it is - <code>fillet.js</code>! It's a script that rounds the corners of any <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code> elements that have a finite, positive rounding radius attribute (<code>r</code>) specified. All we need to do is include the script at the end of the document and... bam! Whenever we specify a valid rounding radius attribute <code>r</code> for a <code>&lt;polygon&gt;</code> or <code>&lt;polyline&gt;</code>, it magically gets rounded corners using that rounding radius or, if the given rounding radius is too big, the maximum rounding radius possible.</p>
		
		<p>This article is going to walk you through the thought process behind the code and show you how <code>fillet.js</code> was built - step by step. So let's get started!</p>
		
		<h2>picking test elements</h2>
		
		<p>For testing our code at every step, we pick two distinct <code>&lt;polygon&gt;</code> elements and two <code>&lt;polyline&gt;</code> elements with the same <code>points</code> attributes as the previously mentioned polygons.</p>
		
		<p>The first <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code> have the minimum number of coordinate pairs needed to create a polygonal shape (closed in the case of the <code>&lt;polygon&gt;</code> and open in the case of the <code>&lt;polyline&gt;</code>) - three. This is so that we make it easier for ourselves to check computations.</p>
		
		<p>For the first closed polygonal chain, we have the following markup:</p>
		
		<pre>&lt;svg viewbox='-50 -50 100 100'>
	&lt;polygon points='50,0 -25,-43.3 -25,43.3' r='10'/>
&lt;/svg></pre>
		
		<p>If we want an open polygonal chain, then we replace <code>polygon</code> with <code>polyline</code> in the code above.</p>
		
		<p>The coordinates listed in the <code>points</code> attribute describe the vertices of an equilateral triangle. Three vertices, three sets of coordinates, all edges equal, equal angles, all three <code>60°</code> ones. Furthermore, the first vertex (the one at <code>50,0</code>) is on the <code><var>x</var></code> axis, so its <code><var>y</var></code> coordinate is <code>0</code>. All chosen this way just to make our life easier when checking whether our code works correctly or not.</p>

		<p>For example, at some step, we may need to compute the angles between edges and, we know that, in this particular case, we should always get <code>60°</code> so, if that's not what our code outputs at that step, then there's something wrong with it.</p>
		
		<figure>
			<img src='images/ini_test_reg.svg' alt='first two polygonal chains we use for testing: the vertices are those of an equilateral triangle, first one of them being on the x axis'/>
			<figcaption>first two polygonal chains we use for testing: the vertices are those of an equilateral triangle, first one of them being on the <code><var>x</var></code> axis</figcaption>
		</figure>
		
		<p>The other two polygonal chains use a completely random list of coordinates for their <code>points</code> attributes. This is to give us a sense of how things work outside the particular case because certain things may be valid for the particular case, but not for the general case and we shouldn't lose sight of that either.</p>
		
		<figure>
			<img src='images/ini_test_rnd.svg' alt='the other two polygonal chains we use for testing are completely random'/>
			<figcaption>the other two polygonal chains we use for testing are completely random; the dashed lines denote the possibility of more vertices being in between those they connect</figcaption>
		</figure>
		
		<p>For all of these four test elements, we've also set an <code>r</code> attribute - this is the rounding radius. It doesn't do anything at this point, but we'll soon start writing the JavaScript code which fixes that.</p>
		
		<p>The value of this rounding radius is completely arbitrary, we took it to be <code>10</code> here because it's a nice round number (it's easier to multiply or divide by <code>10</code> than it is by, let's say, <code>7.8</code>) and it's also big enough relative to their sizes for the rounding it produces to be noticeable.</p>
		
		<h2>vertex, edge and corner (angle) numbering</h2>
		
		<p>Before we sink our teeth into code, let's make sure a few basic concepts are clear.</p>
		
		<p>If we have a <code>points</code> attribute with <code>n</code> pairs of coordinates, then our polygonal chain, whether it's closed (<code>&lt;polygon&gt;</code>) or open (<code>&lt;polyline&gt;</code>) has <code>n</code> vertices: <code>0</code>, <code>1</code>, ... <code>n-1</code>.</p>
		
		<figure>
			<img src='images/nv.svg' alt='if the points attribute has n pairs of coordinates, then our polygonal chain (closed or open, same thing) also has n vertices'/>
			<figcaption>if the <code>points</code> attribute has <code>n</code> pairs of coordinates, then our polygonal chain (closed or open, doesn't matter) also has <code>n</code> vertices</figcaption>
		</figure>
		
		<p>In the <code>&lt;polygon&gt;</code> case, we also have <code>n</code> edges. However, in the <code>&lt;polyline&gt;</code> case, we don't connect the last vertex (<code>n-1</code>) to the first one (<code>0</code>) anymore, so we have one edge less (compared to a <code>&lt;polygon&gt;</code>, a <code>&lt;polyline&gt;</code> with the same <code>points</code> attribute is missing the polygon's last edge). That's <code>n-1</code> edges for the open polygonal chain with <code>n</code> vertices.</p>

		<p>In both cases, we take edge <code>0</code> to be the one between vertex <code>0</code> and vertex <code>1</code>, edge <code>1</code> between vertices <code>1</code> and <code>2</code> and so on. In general, edge <code>i</code> is between vertices <code>i</code> and <code>i+1</code>, where <code>i</code> can be any natural number smaller than the number of edges.</p>
		
		<figure>
			<img src='images/ne.svg' alt='if the points attribute has n pairs of coordinates, then our polygonal chain has n edges if it is closed and n-1 edges if it is open; in general, edge i is between vertices i and i+1 in both cases'/>
			<figcaption>if the <code>points</code> attribute has <code>n</code> pairs of coordinates, then our polygonal chain has <code>n</code> edges if it's closed and <code>n-1</code> edges if it's open; in general, edge <code>i</code> is between vertices <code>i</code> and <code>i+1</code> in both cases</figcaption>
		</figure>
		
		<p class='note'>In the <code>&lt;polygon&gt;</code> case, vertex <code>i+1</code> is actually vertex <code>(i+1)%n</code> - that's what's we're going to use in the JavaScript code, but, for now, we're lazy and we just want to write less.</p>
				
		<p>Now let's move on to corners (angles). These are formed by two consecutive edges meeting at a vertex. In the <code>&lt;polygon&gt;</code> case, we have one at each vertex - that's <code>n</code> corners (angles).</p>
		
		<p>In the <code>&lt;polyline&gt;</code> case however, we don't have two edges meeting at the first (<code>0</code>) and last (<code>n-1</code>) vertices - those are endpoints, we have no corners (angles) there. This makes the number of corners (angles) equal to <code>n-2</code> in this situation.</p>
		
		<figure>
			<img src='images/na.svg' alt='if the points attribute has n pairs of coordinates, then our polygonal chain has n angles if it is closed and n-2 angles if it is open'/>
			<figcaption>if the <code>points</code> attribute has <code>n</code> pairs of coordinates, then our polygonal chain has <code>n</code> corners (angles) if it's closed and <code>n-2</code> corners (angles) if it's open; in general, corner (angle) <code>i</code> is between edges <code>i-1</code> and <code>i</code> in the <code>&lt;polygon&gt;</code> case and between edges <code>i</code> and <code>i+1</code> in the <code>&lt;polyline&gt;</code> case</figcaption>
		</figure>
		
		<p>In the <code>&lt;polygon&gt;</code> case, the first corner (<code>0</code>) is formed where edges <code>n-1</code> and <code>0</code> meet at vertex <code>0</code>, second corner (<code>1</code>) is formed where  edges <code>0</code> and <code>1</code> meet at vertex <code>1</code> and, in general, corner <code>i</code> is formed where edges <code>i-1</code> and <code>i</code> meet at vertex <code>i</code>, where <code>i</code> can be any natural number smaller than the number of corners (<code>n</code>).</p>
		
		<p>In the <code>&lt;polyline&gt;</code> case, the first corner (<code>0</code>) is formed where edges <code>0</code> and <code>1</code> meet at vertex <code>1</code> and, in general, corner <code>i</code> is formed where edges <code>i</code> and <code>i+1</code> meet at vertex <code>i+1</code>, where <code>i</code> can be any natural number smaller than the number of corners (<code>n-2</code>).</p>
		
		<p class='note'>Again, by <code>i-1</code>, we actually mean <code>(i+n-1)%n</code> and by <code>i+1</code> we actually mean <code>(i+1)%n</code> (though it's something we only care about if the polygonal chain is closed).</p>
		
		<p>Let's see what this means in the case of our first two polygonal chains. For the closed chain, we have <code>3</code> vertices, <code>3</code> edges and <code>3</code> corners (angles). For the open chain, we have <code>3</code> vertices, <code>2</code> (<code>=3-1</code>) edges and <code>1</code> (<code>=3-2</code>) corner (angle).</p>
		
		<figure>
			<img src='images/n_reg.svg' alt='numbering vertices (dark blue), edges (light blue) and angles (purple) for a polygonal chain (closed on the left and open on the right) whose vertex coordinates describe an equilateral triangle'/>
			<figcaption>numbering vertices (purple), edges (orange) and angles (pink) for a polygonal chain (closed on the left and open on the right) whose vertex coordinates describe an equilateral triangle</figcaption>
		</figure>
		
		<p>This is important to understand because some of the variables we have to deal with in the JavaScript code are <strong>vertex-related</strong> (for example, an array of vertex coordinates), which means they're arrays of length <code>n</code> in both cases.</p>
		<p>Others are <strong>edge-related</strong> (for example, an array of edge lengths or an array of edge slopes), which means they're arrays of length <code>n</code> in the <code>&lt;polygon&gt;</code> case and of length <code>n-1</code> in the <code>&lt;polyline&gt;</code> case.</p>
		<p>Other variables are <strong>corner-related</strong> (for example, an array of polygonal chain angles or an array of start or end points of each rounding arc), which means they're arrays of length <code>n</code> in the <code>&lt;polygon&gt;</code> case and of length <code>n-2</code> in the <code>&lt;polyline&gt;</code> case.</p>
		
		<h2>the start code</h2>
		
		<p>Now let's go to the JavaScript part. We begin by creating a <code>fillet(_poly)</code> function, which we call for every element that has both a <code>points</code> attribute (because the only two SVG elements that need it are <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code>) and an <code>r</code> attribute (because we only trigger corner rounding if we have a rounding radius specified):</p>

		<pre>function fillet(_poly) {};

const _P = document.querySelectorAll('[points][r]'), 
	NP = _P.length;

for(let i = 0; i &lt; NP; i++)
	fillet(_P[i]);</pre>
		
		<p>Our function doesn't yet do anything, so let's start working on that.</p>
		
		<h2>checking rounding radius validity</h2>
		
		<p>We read the value of the <code>r</code> attribute, <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus'>convert</a> it to a number, then we check that the value we got is a finite, positive number. Otherwise, we exit the function.</p>

		<pre>const R = +_poly.getAttribute('r');

if(!isFinite(R) || R &lt;= 0) return;</pre>
		
		<p>In order to <a href='https://codepen.io/thebabydino/pen/393035a0796efb509ec4ed2afb866728?editors=1011'>test</a> this code, we also try giving the <code>r</code> attribute invalid values.</p>
		
		<h2>extracting vertex coordinates and checking their validity</h2>
		
		<p>Next, we extract the vertex coordinates from the <code>points</code> attribute, checking that they're at least <code>3</code> sets of coordinates, the minimum number needed to create a polygon (because a polygon has at least 3 vertices, in which case it's a triangle). Now we've written nice and clean <code>points</code> attributes for our test polygons and polylines, which makes them easy to split into sets of coordinates. However, differently formatted and messier versions display the exact same result, SVG is pretty forgiving here.</p>
		
		<p>All of the following also result in the exact same <code>&lt;polygon&gt;</code> or <code>&lt;polyline&gt;</code> - note the different comma and space placement, that we may not have any kind of separator before a negative value, that scientific notation is allowed and that we may even have an extra unpaired coordinate at the end:</p>

		<pre>'50,0 -25,-43.3 -25,43.3'
'50,0-25,-43.3-25,43.3'
'50 0 -25 -43.3 -25 43.3'
'50 0-25-43.3-25,43.3'
'50,0-25,-433e-1-25,.433e2'
'50 0,-25 -43.3,-25 43.3'
'50 0 -25,-43.3 -25 43.3'
'50 0,-25 -43.3 -25,43.3'
'50 0,-25 -43.3 -25,43.3 17'
'50, 0 -25, -43.3 -25, 43.3'
'50,0 
-25,-43.3 
-25,43.3' 
'50 ,   0 -25 , -43.3        -25 , 43.3'</pre>

		<p>So, after reading the value of the <code>points</code> attribute, we need to make sure we catch all these possibilities with the regular expression we use to <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split'><code>split()</code></a> the string we get (though first we must insert a separator before negative values if we don't have one) and then, since all the coordinate values are still strings at this point, we convert them to numbers (note that we'll be using <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions'>arrow functions</a> and other ES6 features for our polyfill):</p>

		<pre>let v = _poly.getAttribute('points')
	.replace(/(\d)\-/g, `$1 -`)
	.split(/\s*,\s*|\s+/g)
	.map(c => +c);</pre>

		<p>This makes sure we get the same array if we have the same coordinates, no matter how the <code>points</code> attribute may have been formatted, as it can be seen in <a href='https://codepen.io/thebabydino/pen/d91ca4e8bcabb2962da6e71ba253ac33?editors=1011'>this Pen</a> (we get something like <code>[x<sub>0</sub>, y<sub>0</sub>, x<sub>1</sub>, y<sub>1</sub>, ...]</code>).</p>
		
		<p class='note'>While our code catches all of these situations, you should always put separators even in front of negative-valued coordinates as polygonal chains won't show up in Firefox otherwise, even though Blink browsers and Edge seem to have no issue with this and Firefox does accept <em>path data attributes</em> where the separators in front of negative values are missing.</p>

		<p>Now we check if we have the minimum number of coordinates needed to form a polygon. If not, we exit the function.</p>

		<pre>let n = v.length;
if(.5*n &lt; 3) return;

/* remove the extra unpaired coordinate value 
 * at the end if we have one */
n -= n%2;</pre>

		<p>After that, we check that all useful coordinates are finite numbers. If not, we exit the function, otherwise we compact the linear array of coordinates into a two-dimensional array of <code>x,y</code> pairs of coordinates (so basically, we go from something like <code>[x<sub>0</sub>, y<sub>0</sub>, x<sub>1</sub>, y<sub>1</sub>, ...]</code> to something like <code>[[x<sub>0</sub>, y<sub>0</sub>], [x<sub>1</sub>, y<sub>1</sub>], ...]</code>) using <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce'><code>reduce()</code></a>.</p>

		<pre>for(let i = 0; i &lt; n; i++)
	if(!isFinite(v[i])) return;

// a, c, i = accumulator, current item, current index
v = v.reduce((a, c, i) => i%2 ? a.concat([[v[i - 1], c]]) : a, []);

n = v.length;</pre>

		<p><a href='https://codepen.io/thebabydino/pen/4b263549df6413cec17ab3cec4f23619?editors=1011'>This Pen</a> tests that the above code works as intended.</p>
		
		<h2>getting the type of shape</h2>
		
		<p>So far, it didn't matter whether our shape is a <code>&lt;polygon&gt;</code> or a <code>&lt;polyline&gt;</code> because we've only dealt with invariant things (the polygonal chain itself <code>_poly</code>, its rounding radius <code>R</code>) or with vertex-related ones (the array of vertex coordinates <code>v</code>).</p>
		
		<p>But things are about to change, so we need to get the type of polygonal shape we're dealing with:</p>
		
		<pre>let τ = +(_poly.localName !== 'polygon');</pre>
		
		<p><code>τ</code> is <code>0</code> for a <code>&lt;polygon&gt;</code> element and <code>1</code> for a <code>&lt;polyline&gt;</code>, as it can be tested <a href='https://codepen.io/thebabydino/pen/4b6a361c302c1db1ab4b8bc69c127824?editors=1011'>here</a>.</p>
		
		<h2>checking for collinearity and eliminating unneeded vertices</h2>
		
		<p>We're doing one more check here before we start working on the rounding and that's to see that no three consecutive points are <a href='http://mathworld.wolfram.com/Collinear.html'>collinear</a>. If that happens to be the case, we remove the one in the middle (the second of the three) because we don't really need it - with or without it, our shape is the same. The illustration below shows this:</p>
		
		<figure>
			<img src='images/collin_mid_reg.svg' alt='points 1, 2 and 3 are collinear; the one in the middle of these three is not a real vertex, so we can safely remove it'/>
			<figcaption><code>1</code>, <code>2</code> and <code>3</code> (first column) are collinear; <code>2</code> (first column) isn't a real vertex, so we can safely remove it and then shift indices (second column)</figcaption>
		</figure>
		
		<p>Points <code>1</code>, <code>2</code> and <code>3</code> (first column) are collinear. Point <code>2</code> (first column) isn't a real vertex, just a point on the segment between the previous (<code>1</code>) and the next (<code>3</code>) points. Removing it and shifting the indices of the points that come after it doesn't alter our shape, but reduces our code and makes our life easier.</p>
			
		<p>If removing a vertex happens to leave us with less than <code>3</code> vertices, then we exit the function.</p>
		
		<p>Whether we have a closed or an open polygonal chain, we need to perform this check for every possible group of three consecutive points.</p>
		
		<p>In the <code>&lt;polyline&gt;</code> case, these groups are:</p>
		
		<pre>0, 1, 2
1, 2, 3
...
i-1, i, i+1
...
n-3, n-2, n-1</pre>
		
		<p>The general form of these groups is <code>i-1, i, i+1</code>, where <code>1 &le; i &lt; n-1</code>.</p>
		
		<p>In the <code>&lt;polygon&gt;</code> case however, the list of points is cyclic. This means that the first point (<code>0</code>) has a previous one (which is the last point, <code>n-1</code>) and the last point (<code>n-1</code>) has a next one (which is the first point, <code>0</code>). So in this case, our groups are:</p>
		
		<pre><strong>n-1, 0, 1</strong>
0, 1, 2
1, 2, 3
...
i-1, i, i+1
...
n-3, n-2, n-1
<strong>n-2, n-1, 0</strong></pre>
		
		<p>The general form of these groups is pretty much the same as before, <code>(i-1+n)%n, i, (i+1)%n</code>, it's just that this time <code>0 &le; i &lt; n</code>.</p>
		
		<p>The geometric interpretation of this is that, in the <code>&lt;polyline&gt;</code> case, adding a point that's collinear with the first and the last at the beginning (or at the end) of the list of points gives us a different shape from the initial one. In the <code>&lt;polygon&gt;</code> case, this doesn't happen, we still have the same shape. This is why such a point is safe to remove in the <code>&lt;polygon&gt;</code> case, but not in the <code>&lt;polyline&gt;</code> one (we'd lose an edge in this situation).</p>
		
		<p>The following image illustrates this. The first row presents the <code>&lt;polygon&gt;</code> case, while the second one presents the <code>&lt;polyline&gt;</code> case. The first colums shows the initial shapes. The second one shows the result of adding a point collinear with the first and last at the beginning of the list of points. The third one shows the result of adding a point collinear with the first and last at the end of the list of points.</p>
		
		<figure>
			<img src='images/collin_end_reg.svg' alt='adding a point that is collinear to the first and the last at the beginning or at the end in the <polygon> case (top row, same shape in all cases) vs. in the <polyline> case (bottom row, different shapes); first colum shows the initial polygonal chains, while others show the results of adding a point that is collinear to the first and the last at the beginning (column two) or at the end (column three)'/>
			<figcaption>adding a point that's collinear to the first and the last at the beginning or at the end in the <code>&lt;polygon&gt;</code> case (top row, same shape in all cases) vs. in the <code>&lt;polyline&gt;</code> case (bottom row, different shapes); first colum shows the initial polygonal chains, while others show the results of adding a point that's collinear to the first and the last at the beginning (column two) or at the end (column three)</figcaption>
		</figure>
		
		<p>In the <code>&lt;polygon&gt;</code> case, adding this extra point doesn't modify the shape. The newly added point isn't a new vertex, just a point on an already existing edge and the segments that start from it aren't two distinct edges, just two parts of the same edge.</p>
		
		<p>In the <code>&lt;polyline&gt;</code> case however, the newly added point is a new vertex, even if it's on the same line with the initial endpoints. This is because the initial endpoints aren't connected and, due to the nature of the polyline, this point doesn't get connected to both, only to one of them.</p>
		
		<p>Alright, let's see how we can determine whether three points are collinear. Or <em>almost</em> collinear because sometimes rounding errors come into play. Consider the situation of our test triangle. Its last edge is between points <code>-25,43.3</code> and <code>50,0</code>. If we take the point where this edge intersects the <code><var>y</var></code> axis, this point is <code>0,28.9</code>.</p>
		
		<figure>
			<img src='images/test_tri_y_int.svg' alt=''/>
			<figcaption>the last edge of our test triangle intersects the <code><var>y</var></code> axis at <code>0,28.9</code></figcaption>
		</figure>		
		
		<p>Now the <code>43.3</code> and <code>28.9</code> values are actually rounded values so that we don't have write a truckload of decimals - you have to admit, values like <code>43.301270189221932338186158537647</code> look ugly and nobody wants to write them by hand or even copy-paste them around, especially since dropping all decimals after the first doesn't visibly affect our shape. Not to mention that putting that long sausage of characters into the SVG figures showing the test triangle would have completely ruined them.</p>

		<p>However, this rounding also means that these three points will fail a <em>strict</em> collinearity check, which is why we need to leave a bit of room for error.</p>
		
		<p>But what exactly does the collinearity check involve? It involves checking whether the angle between the two edges formed by our three consecutive points is either really close to <code>0°</code> or really close to <code>180°</code>, where "really close" means within error limits. If our cutoff angle is, let's say <code>1°</code>, then we get a positive for our collinearity check when the the angle between the two edges formed by the three consecutive points is either smaller than <code>1°</code> or larger than <code>180° - 1° = 179°</code>.</p>
		
		<p>This means we need to compute the angles of our polygonal chain. We do this using <a href='https://en.wikipedia.org/wiki/Law_of_cosines'>the law of cosines</a>. This gives us the cosine of an angle of a triangle as a function of the edge lengths of that triangle. Given the shape of the cosine graph on the <code>[0°, 180°]</code> interval, our almost collinearity check reduces to checking that the absolute value of the cosine we get is smaller than the cosine of a cutoff angle, as illustrated by the following interactive demo (drag the slider thumb):</p>
		
		<p data-height="500" data-theme-id="0" data-slug-hash="ygGbYG" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="cut out parts of cos graph close to ±1" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/ygGbYG/">cut out parts of cos graph close to ±1</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
		
		<p>The vertical lines represent the angular boundaries beyond which the angle formed by the three points we consider is either almost <code>0°</code> or almost <code>180°</code>. The horizontal lines represent the boundaries beyond which the cosine of our angle in absolute value is greater than the threshold error, where the threshold error is the cosine of our cutoff angle.</p>
		
		<p>What we end up doing is discard the values in the hashed area since those angles are really close to either <code>0°</code> or <code>180°</code>. This means discarding the vertices where we have angles that are less than a cutoff angle away from <code>0°</code> or <code>180°</code> and the way we check that is by comparing the value of their cosine in absolute value to the value of the cosine of the cutoff angle (the threshold error).</p>
		
		<p class='note'>Note that, even though the cosine function decreases slowly at the ends of the <code>[0°, 180°]</code> interval, we don't really need a large cutoff value to catch rounding errors - a <code>.1°</code> would suffice so that we don't have issues in the case of rounded coordinates for our test triangle.</p>
		
		<p>Alright, but getting the cosine requires that we know the edge lengths, so we need to compute these first, before we get to the angles. Let's see how!</p>
		
		<p>Consider the generic edge <code>i</code>. This is between vertices <var>A<sub>i</sub></var> and <var>A<sub>i+1</sub></var>. We first draw a horizontal line through <var>A<sub>i</sub></var>, then we project <var>A<sub>i+1</sub></var> onto the horizontal line we've drawn previously.</p>
		
		<figure>
			<img src='images/edge_right_tri_base.svg' alt='we draw a horizontal line through point i, then we project point i+1 onto it'/>
			<figcaption>we draw a horizontal line through <var>A<sub>i</sub></var>, then we project <var>A<sub>i+1</sub></var> onto it</figcaption>
		</figure>
		
		<p><var>A<sub>i+1</sub>T<sub>i+1</sub></var> is perpendicular onto the horizontal, which means that it's a vertical line. This also means that the <var>A<sub>i</sub>A<sub>i+1</sub>T<sub>i+1</sub></var> triangle we've just created is a right triangle where we know the coordinates of all three vertices.</p>
		
		<figure>
			<img src='images/edge_right_tri_d.svg' alt='we get a right triangle where we know the coordinates of all three vertices'/>
			<figcaption><var>A<sub>i</sub>T<sub>i+1</sub>A<sub>i+1</sub></var> is a right triangle where we know the coordinates of all three vertices</figcaption>
		</figure>
		
			<p>In the right triangle <var>A<sub>i</sub>T<sub>i+1</sub>A<sub>i+1</sub></var>, the <var>T<sub>i+1</sub></var> vertex is on the same horizontal line as <var>A<sub>i</sub></var>, so it has the same <code><var>y</var></code> coordinate (<code>y<sub>i</sub></code>). It's also on the same vertical line as <var>A<sub>i+1</sub></var>, so it has the same <code><var>x</var></code> coordinate (<code>x<sub>i+1</sur></code>). Since the <var>A<sub>i</sub>T<sub>i+1</sub></var> segment is a horizontal one, its length is the difference between the <code><var>x</var></code> coordinates of the two points:</p>
		
		<pre><var>dx<sub>i</sub></var> = x<sub>i+1</sub> - x<sub>i</sub></pre>
		
		<p>Similarly, since the <var>T<sub>i+1</sub>A<sub>i+1</sub></var> segment is a vertical one, its length is the difference between the <code><var>y</var></code> coordinates of the two points:</p>
		
		<pre><var>dy<sub>i</sub></var> = y<sub>i+1</sub> - y<sub>i</sub></pre>
		
		<p>Since we compute these coordinate differences between the ends of each edge, that makes them edge-related - we have as many such coordinate differences as edges - that is <code>n</code> in the <code>&lt;polygon&gt;</code> case and <code>n-1</code> in the <code>&lt;polyline&gt;</code> case. We'll be needing these coordinate differences for more than one thing, so we compute them and store them in an array <code>d</code>. Every item in this array is a pair of differences along the two axes.</p>
		
		<p>Whether we have a closed or an open polygonal chain, the value of pair <code>i</code> depends on the coordinates of vertex <code>i</code> and on those of vertex <code>i+1</code>.</p>
		
		<pre><var>d<sub>i</sub></var> = fn(v<sub>i</sub>, v<sub>i+1</sub>)</pre>
		
		<figure>
			<img src='images/edge_diff_diagr.svg' alt='diagram showing how getting coordinate differences between edge endpoints from vertex coordinates works in the two cases: <polygon> (top) vs. <polyline> (bottom)'/>
			<figcaption>diagram showing how getting coordinate differences between edge endpoints from vertex coordinates works in the two cases: <code>&lt;polygon&gt;</code> (top) vs. <code>&lt;polyline&gt;</code> (bottom)</figcaption>
		</figure>
		
		<p>Putting all this into code, we start from the 2D array of vertex coordinates <code>v</code>, which we <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map'><code>map()</code></a> to another 2D array of differences <code>d</code>:</p>
		
		<pre>let ne = n - τ; /* number of edges */

let d = v.slice(0, ne).map((c, i) => {
	let nxτ = v[(i + 1)%n]; /* next vertex coords */

	return [
		nxt[0] - c[0] /* x difference dx */, 
		nxt[1] - c[1] /* y difference dy */
	];
});</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/bb3e7b893910133f070d9448208f9741?editors=0011'>This Pen</a> checks that the above code works as expected - if we have three vertices, then we should have <code>3</code> sets of coordinate differences if the polygonal chain is closed and <code>2</code> sets of coordinate differences if the polygonal chain is open.</p>
		
		<p>Next, we need to compute the edge lengths. In order to see how we do that for the generic edge <code>i</code> (<var>A<sub>i</sub>A<sub>i+1</sub></var>), let's go back to our right triangle:</p>
		
		<figure>
			<img src='images/edge_right_tri_l.svg' alt='in this right triangle, edge i is the hypotenue'/>
			<figcaption>in the right triangle <var>A<sub>i</sub>A<sub>i+1</sub>T<sub>i+1</sub></var>, <var>A<sub>i</sub>A<sub>i+1</sub></var> is the hypotenuse</figcaption>
		</figure>
		
		<p>In this triangle, <var>A<sub>i</sub>A<sub>i+1</sub></var> (<code><var>l<sub>i</sub></var></code>) is the hypotenuse, so we can compute it using the Pythagorean theorem:</p>
		
		<pre><var>l<sub>i</sub></var> = √(dx<sub>i</sub><sup>2</sup> + dy<sub>i</sub><sup>2</sup>)</pre>
		
		<p>In our JS code, this would be:</p>
		
		<pre>let l = d.map(c => Math.hypot(...c));</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/508892035bde4fd3cf68833a850e4a1d?editors=0011'>This Pen</a> checks that we get equal edge lengths for our test cases where the vertices are those of an equilateral triangle.</p>
		
		<p>The law of cosines states that the cosine of the angle <code><var>α</var></code> of a triangle equals the sum of the squares of the two edges that form it (<code>b</code> and <code>c</code>) minus the square of the opposing edge (<code>a</code>), all divided by twice the product between the two adjacent edges (<code>b</code> and <code>c</code>):</p>
		
		<pre>cos(<var>α</var>) = (b<sup>2</sup> + c<sup>2</sup> - <var>a<sup>2</sup></var>)/(2·b·c)</pre>
		
		<p>We already know <code>b</code> and <code>c</code> - they're the two polygonal edges that form the angle we want to get. In the <code>&lt;polygon&gt;</code> case, the two edges forming angle <code>i</code> are <var>A<sub>i-1</sub>A<sub>i</sub></var> (<code>i-1</code>) and <var>A<sub>i</sub>A<sub>i+1</sub></var> (<code>i</code>). In the <code>&lt;polyline&gt;</code> case, the two edges forming angle <code>i</code> are <var>A<sub>i</sub>A<sub>i+1</sub></var> (<code>i</code>) and <var>A<sub>i+1</sub>A<sub>i+2</sub></var> (<code>i+1</code>).</p>
		
		<figure>
			<img src='images/ang_i.svg' alt='the edges that form angle i are i-1 and i in the <polygon> case, but i and i+1 in the <polyline> case'/>
			<figcaption>the edges that form angle <code>i</code> are <code>i-1</code> and <code>i</code> in the <code>&lt;polygon&gt;</code> case (left), but <code>i</code> and <code>i+1</code> in the <code>&lt;polyline&gt;</code> case (right)</figcaption>
		</figure>
		
		<p>In general, given that <code>τ</code> is <code>0</code> for a <code>&lt;polygon&gt;</code> and <code>1</code> for a <code>&lt;polyline&gt;</code>, the two edges we want (the <code>b</code> and <code>c</code> in the law of cosines) are <var>A<sub>i-1+τ</sub>A<sub>i+τ</sub></var> (<code>i-1+τ</code>) and <var>A<sub>i+τ</sub>A<sub>i+1+τ</sub></var></code> (<code>i+τ</code>).</p>
		
		<p>But what about the edge opposing our angle <code><var>α</var></code> - edge <code><var>a</var></code>? Well, we don't know it yet, but we can compute it in the same manner as the other two - from the coordinates of its endpoints. These are the start point of the first edge forming our angle (<var>A<sub>i-1</sub></var> in the <code>&lt;polygon&gt;</code> case and <var>A<sub>i</sub></var> in the <code>&lt;polyline&gt;</code> case) and the end point of the second edge forming our angle (<var>A<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case and <var>A<sub>i+1</sub></var> in the <code>&lt;polyline&gt;</code> case). This means that, in the general case, our <code><var>a</var></code> is the <var>A<sub>i-1+τ</sub>A<sub>i+1+τ</sub></var> segment.</p>
		
		<figure>
			<img src='images/collin_a.svg' alt='the third edge we need to compute angle i using the law of cosines in the <polygon> case (left) and in the <polyline> case (right)'/>
			<figcaption>the third edge we need to compute angle <code>i</code> using the law of cosines in the <code>&lt;polygon&gt;</code> case (left) and in the <code>&lt;polyline&gt;</code> case (right)</figcaption>
		</figure>
		
		<p>So if the polygonal chain is closed, the angle <code><var>α<sub>i</sub></var></code> depends on the lengths of edges <code>i-1</code> and <code>i</code> and on the coordinates of vertices <code>i-1</code> and <code>i+1</code>:</p>
		
		<pre><var>α<sub>i</sub></var> = fn(l<sub>i-1</sub>, l<sub>i</sub>, v<sub>i-1</sub>, v<sub>i+1</sub>)</pre>
		
		<p>If the polygonal chain is open, the angle <code><var>α<sub>i</sub></var></code> depends on the lengths of edges <code>i</code> and <code>i+1</code> and on the coordinates of vertices <code>i</code> and <code>i+2</code>:</p>
		
		<pre><var>α<sub>i</sub></var> = fn(l<sub>i</sub>, l<sub>i+1</sub>, v<sub>i</sub>, v<sub>i+2</sub>)</pre>
		
		<p>The following diagram illustrates the above:</p>
		
		<figure>
			<img src='images/vx_ang_diagr.svg' alt='diagram showing how computing angles using the law of cosines from edge lengths and vertex coordinates works in the two cases: <polygon> (top) vs. <polyline> (bottom)'/>
			<figcaption>diagram showing how computing angles using the law of cosines from edge lengths and vertex coordinates works in the two cases: <code>&lt;polygon&gt;</code> (top) vs. <code>&lt;polyline&gt;</code> (bottom)</figcaption>
		</figure>
		
		<p>Unifying the two cases, we have:</p>
		
		<pre><var>α<sub>i</sub></var> = fn(l<sub>i-1+τ</sub>, l<sub>i+τ</sub>, v<sub>i-1+τ</sub>, v<sub>i+1+τ</sub>)</pre>
		
		<p>Putting all of this into JS code, we have:</p>
		
		<pre>const CA = .25; /* cutoff angle in degrees */

function fillet(_poly) {
	/* threshold error = cosine of cutoff angle */
	const TE = Math.cos((_poly.hasAttribute('data-ca') ? 
					 _poly.getAttribute('data-ca') : CA)*Math.PI/180)
	
	/* same code a before */
	
	let α = [];
	
	for(let i = τ; i &lt; ne; i++) {
		let j = (i - 1 + n)%n /* first edge index */, 
				k = (i + 1)%n /* second edge index */, 
				/* third edge endpoint coord differences */
				dx = v[j][0] - v[k][0], 
				dy = v[j][1] - v[k][1], 
				c = Math.hypot(dx, dy) /* third edge */, 
				/* cosine of current angle from law of cosines */
				h = (l[i]*l[i] + l[j]*l[j] - c*c)/(2*l[i]*l[j]);
		
		/* if current cosine greater than threshold error */
		if(Math.abs(h) > TE) {
			/* remove middle vertex */
			v.splice(i, 1);
			/* update number of vertices
			 * and exit if we're left with less than 3*/
			if(--n &lt; 3) return;
			
			/* remove coord diffs related to removed vertex, 
			 * introduce those between adjacent vertices */
			d.splice(j, 2, [dx, dy]);
			/* remove edges connected to removed vertex
			 * introduce shortcircuiting segment */
			l.splice(j, 2, c);
			ne--; /* update number of edges */
			
			/* decrement index */
			i = Math.max(i - 2, τ - 1);
			/* to fix previous angle */
			if(α.length) α.pop();
		}
		else α.push(Math.acos(h));
	}
}</pre>
		
		<p>Since we don't want the threshold error to be set in stone, we've left the option of easily overriding the cutoff angle for each polygonal chain via a <code>data-ca</code> attribute which takes degree values.</p>
		
		<p>Also, every time we remove a vertex, we also discard the angle we've computed for the previous vertex if there is one (<code>if(α.length) α.pop()</code>) so that we recompute it and get a more accurate value. This is also why we're decrementing the index by <code>2</code> (<code>i-2</code>), not just by <code>1</code>. However, we don't want to run the risk that during the next iteration, the current index is less than the start one (<code>τ</code>), which is why we set a lower limit of <code>τ-1</code> on the decremented index.</p>
		
		<p>To better understand why we recompute the previous angle if we've removed a vertex, consider the following part of a polygonal chain illustrated below:</p>
		
		<figure>
			<img src='images/rem_ini.svg' alt='highlighting an almost collinearity situation in a polygonal chain'/>
			<figcaption>highlighting an almost collinearity situation in a polygonal chain</figcaption>
		</figure>
		
		<p>Our collinearity check reveals that vertices <var>A<sub>r-1</sub></var>, <var>A<sub>r</sub></var> and <var>A<sub>r+1</sub></var> are almost collinear, so we can remove the one in the middle, shift vertex numbering, remove the two edges connected to the removed vertex and replace them with the segment connecting the vertices before and after.</p>
		
		<figure>
			<img src='images/rem_fin.svg' alt="after removing the vertex we don't need, our angles are slightly different"/>
			<figcaption>after removing the vertex we don't need, our angles are slightly different</figcaption>
		</figure>
		
		<p>All good, but note how this slighly changes the angles at two vertices before and after the removed point (pale pink before, bright pink after). We haven't yet computed the angle for the vertex after and, when we do that, we'll take into account the new polygonal chain, but we've already computed the one before and we've already added it to the <code>α</code> array. We can recompute it, but we don't want to add it twice to the array of angles <code>α</code>, so we pop out the last item in this array and we make the current index of the loop go back one extra step.</p>
		
		<p>However, there's one more case to consider. Let's say that the vertex we remove is the last one and that the polygonal chain is closed. Then, the "next" vertex is the first one and we've already computed the angle at that vertex. In fact, it was the first one we've computed - <code>α[0]</code>. So what we need to do in order to also cover this case is to recompute the first angle (<code>α[0]</code>) right before we make the loop index go back:</p>
		
		<pre>if(!τ && i === ne) {
	dx = v[i - 1][0] - v[k][0];
	dy = v[i - 1][1] - v[k][1];
	c = Math.hypot(dx, dy);
	h = (l[i-1]*l[i-1] + l[0]*l[0] - c*c)/(2*l[i-1]*l[0]);
	α[0] = Math.acos(h);
}</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/60719d964942f94cd6fde3c3fab4b933?editors=0011'>This Pen</a> checks that all angles are <code>60°</code> ones if the vertices of our test polygonal chain are those of an equilateral triangle, maybe with some points on this triangle's edges in between.</p>
		
		<p class='note'>Note that the angles in the illustrations above are exaggerated and would correspond to a way larger error margin than we really use. So we may well skip the recomputations altogether as they don't really make that big of a difference. For an almost collinearity situation like that given by rounding errors as in the example seen earlier, the increase in accuracy is of under <code>.03°</code> - in order to get an angle that small, we must divide the circle into <code>12000</code> equal parts.</p>
		
		<h2>recap of what we know so far</h2>
		
		<p>Now that we got edge cases out of the way, let's see what we have so far:</p>
		
		<ul>
			<li>the rounding radius <code>r</code>, which we've extracted from the <code>r</code> attribute</li>
			<li>the vertex coordinates (the <code>v</code> array) of the initial polygonal chain, which we've extracted from the <code>points</code> attribute</li>
			<li>the number (<code>n</code>) of vertices</li>
			<li>whether our polygonal chain is closed (<code>τ=0</code>) or open(<code>τ=1</code>)</li>
			<li>the differences between all the pairs of consecutive vertex coordinates (the <code>d</code> array)</li>
			<li>the edge lengths (the <code>l</code> array) of our polygonal chain</li>
			<li>the number (<code>ne</code>) of edges</li>
			<li>the angles (the <code>α</code> array) of our polygonal chain</li>
		</ul>
		
		<h2>how rounding corners works</h2>
		
		<p>A polygonal chain with rounded corners is equivalent to a path made up of straight line segments (one along each proper edge of the initial polygonal chain) and arcs (one replacing each corner of the initial polygonal chain).</p>
		
		<figure>
			<img src='images/path_equiv_vs_orig_rnd.svg' alt='equivalent paths for polygonal chains with rounded corners where the start and end points for each arc are marked on the figure'/>
			<figcaption>equivalent paths for polygonal chains with rounded corners where the start and end points for each arc are marked on the figure; note how in the <code>&lt;polygon&gt;</code> case, arc <code>i</code> is at vertex <code>i</code> (and we have <code>n</code> arcs in total), while in the <code>&lt;polyline&gt;</code> case, it's at vertex <code>i+1</code> (and we only have <code>n-2</code> arcs in total, as the first and last vertices are endpoints and we don't have arcs there)</figcaption>
		</figure>
		
		<p>This <code>&lt;path&gt;</code> element's data (<code>d</code>) attribute is made up of:</p>

		<ul>
			<li>a "move to" (<code>M</code>) command followed by the coordinates of the point where our path starts;
				<ul>
					<li>in the <code>&lt;polygon&gt;</code> case, this is the start point of the first arc (<var>S<sub>0</sub></var>), whose coordinates are <code><var>xs<sub>0</sub></var>,<var>ys<sub>0</sub></var></code> (still unknown at this point);
					</li>
					<li>in the <code>&lt;polyline&gt;</code> case, this is the first vertex of the initial <code>&lt;polyline&gt;</code> (<var>A<sub>0</sub></var>), whose coordinates are <code>x<sub>0</sub>,y<sub>0</sub></code> (which we already have);</li>
				</ul>
			</li>
			<li>an "arc to" (<code>A</code>) command for every <code>i</code>-th arc (where <code>0 &le; i &lt; n</code> in the <code>&lt;polygon&gt;</code> case and <code>0 &le; i &lt; n-2</code> in the <code>&lt;polyline&gt;</code> case); this draws the arc between its start point (<var>S<sub>i</sub></var>) and its end point (<var>E<sub>i</sub></var>);</li>
			<li>a "line to" (<code>L</code>) command for every <code>i</code>-th segment where <code>0 &le; i &lt; n-1</code>, followed by the coordinates point where this line segment ends;
				<ul>
					<li>in the <code>&lt;polygon&gt;</code> case, this is the start point of the next arc (<var>S<sub>i+1</sub></var>), whose coordinates are <code><var>xs<sub>i+1</var></sub>,<var>ys<sub>i+1</var></sub></code>; also, this line segment starts from the end point of the arc we've just drawn (<var>E<sub>i</sub></var>, of coordinates <code><var>xe<sub>i</var></sub>,<var>ye<sub>i</var></sub></code>);</li>
					<li>in the <code>&lt;polyline&gt;</code> case, this is either the start point of the next arc (<var>S<sub>i+1</sub></var>), whose coordinates are <code><var>xs<sub>i+1</var></sub>,<var>ys<sub>i+1</var></sub></code> (still unknown at this point) or the last vertex of the initial <code>&lt;polyline&gt;</code> (<var>A<sub>n-1</sub></var>), whose coordinates are <code>x<sub>n-1</sub>,y<sub>n-1</sub></code> (which we already have); also, this line segment starts either from the first vertex of the initial <code>&lt;polyline&gt;</code> (<var>A<sub>0</sub></var>), whose coordinates are <code>x<sub>0</sub>,y<sub>0</sub></code> (which we already have) or from the end point of the arc we've just drawn (<var>E<sub>i</sub></var>), of coordinates <code><var>xe<sub>i</var></sub>,<var>ye<sub>i</var></sub></code> (still unknown at this point);</li>
				</ul>
			</li>
			<li><strong>only in the <code>&lt;polygon&gt;</code> case</strong>, a "close path" (<code>z</code>) command at the end which connects the end point of the last arc (<var>E<sub>n-1</sub></var> of coordinates <code><var>xe<sub>n-1</sub></var>,<var>ye<sub>n-1</sub></var></code>) to the start point of our path (also the start point of the first arc <var>S<sub>0</sub></var>);</li>
		</ul>
		
		<h2>the "arc to" (<code>A</code>) command</h2>
		
		<p>Let's take a closer look at the components of an "arc to" command. We have the following:</p>

		<ul>
			<li>the radius of this arc along the <code><var>x</var></code> axis of its system of coordinates - this is equal to the rounding radius <code>R</code></li>
			<li>the radius of this arc along the <code><var>y</var></code> axis of its system of coordinates - this is also equal to the rounding radius <code>R</code></li>
			<li>the rotation of its system of coordinates - this doesn't matter in our case since the radii along the two 2D dimensions (<code>x</code> and <code>y</code>) are equal, so we take it to be <code>0</code> to keep things as simple as possible</li>
			<li>the large arc flag - this is <code>0</code> in our case since we always take the small arc at a vertex (the one inside the small angle, the one under <code>180°</code></li>
			<li>the sweep flag <code><var>f<sub>i</sub></var></code> - this is <code>1</code> if the arc goes clockwise between its start and its end point and <code>0</code> otherwise; it's something we need to compute for each arc</li>
			<li>the <code><var>x</var></code> coordinate of the arc's end point - this is <code><var>xe<sub>i</sub></var></code> for the generic <code>i</code>-th arc</li>
			<li>the <code><var>y</var></code> coordinate of the arc's end point - this is <code><var>ye<sub>i</sub></var></code> for the generic <code>i</code>-th arc</li>
		</ul>
		
		<h2>path data structure</h2>
		
		<p>Knowing all this, our path data is going to look something like this for the <code>&lt;polygon&gt;</code> case:</p>

		<pre>M <var>xs<sub>0</sub></var>, <var>ys<sub>0</sub></var>
A R, R, , 0, 0, <var>f<sub>0</sub></var>, <var>xe<sub>0</sub></var>, <var>ye<sub>0</sub></var>
L <var>xs<sub>1</sub></var>, <var>ys<sub>1</sub></var>
A R, R, , 0, 0, <var>f<sub>1</sub></var>, <var>xe<sub>1</sub></var>, <var>ye<sub>1</sub></var>
...
L <var>xs<sub>i</sub></var>, <var>ys<sub>i</sub></var>
A R, R, , 0, 0, <var>f<sub>i</sub></var>, <var>xe<sub>i</sub></var>, <var>ye<sub>i</sub></var>
...
L <var>xs<sub>n-2</sub></var>, <var>ys<sub>n-2</sub></var>
A R, R, , 0, 0, <var>f<sub>n-2</sub></var>, <var>xe<sub>n-2</sub></var>, <var>ye<sub>n-2</sub></var>
L <var>xs<sub>n-1</sub></var>, <var>ys<sub>n-1</sub></var>
A R, R, , 0, 0, <var>f<sub>n-1</sub></var>, <var>xe<sub>n-1</sub></var>, <var>ye<sub>n-1</sub></var>
z</pre>
		
		<p>In the <code>&lt;polyline&gt;</code> case, things look a bit different:</p>
		
		<pre>M x<sub>0</sub>, y<sub>0</sub>
L <var>xs<sub>0</sub></var>, <var>ys<sub>0</sub></var>
A R, R, , 0, 0, <var>f<sub>0</sub></var>, <var>xe<sub>0</sub></var>, <var>ye<sub>0</sub></var>
L <var>xs<sub>1</sub></var>, <var>ys<sub>1</sub></var>
A R, R, , 0, 0, <var>f<sub>1</sub></var>, <var>xe<sub>1</sub></var>, <var>ye<sub>1</sub></var>
...
L <var>xs<sub>i</sub></var>, <var>ys<sub>i</sub></var>
A R, R, , 0, 0, <var>f<sub>i</sub></var>, <var>xe<sub>i</sub></var>, <var>ye<sub>i</sub></var>
...
L <var>xs<sub>n-3</sub></var>, <var>ys<sub>n-3</sub></var>
A R, R, , 0, 0, <var>f<sub>n-3</sub></var>, <var>xe<sub>n-3</sub></var>, <var>ye<sub>n-3</sub></var>
L x<sub>n-1</sub>, y<sub>n-1</sub></pre>
		
		<p>However, in the end, we still need to get the same three things for each arc <code>i</code>, whether the number of arcs is <code>n</code> (closed polygonal chain) or <code>n-2</code> (open polygonal chain):</p>
		
		<ul>
			<li>whether it goes clockwise or not, which determines the value (<code>1</code> or <code>0</code>) for its sweep flag <code><var>f<sub>i</sub></var></code></li>
			<li>the coordinates <code><var>xs<sub>i</sub></var>,<var>ys<sub>i</sub></var></code> of its start point <var>S<sub>i</sub></var></li>
			<li>the coordinates <code><var>xe<sub>i</sub></var>,<var>ye<sub>i</sub></var></code> of its end point <var>E<sub>i</sub></var></li>
		</ul>
		
		<h2>sweep flags</h2>
		
		<p>For every arc, the value of its sweep flag <code><var>f</var></code> is determined by whether the arc goes clockwise (in which case it's <code>1</code>) or not (in which case it's <code>0</code>).</p>
		
		<p>We can get the direction of the arc replacing vertex <code>i</code> by <a href='https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon'>computing the following sum</a>:</p>
		
		<pre>(x<sub>i  </sub> - x<sub>i-1</sub>)·(y<sub>i+1</sub> - y<sub>i  </sub>) - 
(x<sub>i+1</sub> - x<sub>i  </sub>)·(y<sub>i  </sub> - y<sub>i-1</sub>)</pre>
		
		<p>But these are the same coordinate differences we've already computed earlier, so our sum becomes:</p>
		
		<pre>dx<sub>i-1</sub>·dy<sub>i</sub> - dx<sub>i</sub>·dy<sub>i-1</sub></pre>
		
		<p>If this sum is positive, then the arc goes in the clockwise direction and the sweep flag for the arc we replace vertex <code>i</code> with is <code>1</code>. If it's negative, then the arc goes counterclockwise and the sweep flag is <code>0</code>. But what if it's exactly <code>0</code>? Well, that cannot happen. Half the absolute value of this sum happens to be exactly the area of the triangle formed by the <code>i-1</code>, <code>i</code> and <code>i+1</code> points, which is zero only when these three points are collinear and we've already excluded that situation.</p>

		<p>If the sum is positive, then the sign of the sum is <code>+</code> (the value of the <a href='https://en.wikipedia.org/wiki/Sign_function'>sign function</a> is <code>1</code>) and the corresponding sweep flag is <code>1</code>. If the sum is negative, then the sign of the sum is <code>-</code> (the value of the sign function is <code>-1</code>) and corresponding sweep flag is <code>0</code>.</p>
				
		<p>This helps us extract a formula for the sweep flag of the arc replacing the corner at vertex <code>i</code>:</p>

		<pre>.5·(sgn(dx<sub>i-1</sub>·dy<sub>i</sub> - dx<sub>i</sub>·dy<sub>i-1</sub>) + 1)</pre>
		
		<p>We can check that this works for both a positive sum (<code>.5·(1 + 1) = .5·2 = 1</code>) as well as for a negative one (<code>.5·(-1 + 1) = .5·0 = 0</code>).</p>
		
		<p>A very important thing to keep in mind is that that arc <code>i</code> replaces vertex <code>i</code> only for a closed polygonal chain. For an open one, it replaces vertex <code>i+1</code>. This is because the array of sweep flags (like all other variables that define an arc, such as the coordinates of its endpoints) is corner-related - we have a sweep flag for each arc, but we have no arcs at the vertices where we don't have corners (the endpoints of a <code>&lt;polyline&gt;</code>).</p>
		
		<figure>
			<img src='images/sweep_f_arc.svg' alt='the rounding arcs highlighted for the two random polygonal chains: closed (left) vs. open (right)'/>
			<figcaption>the rounding arcs highlighted for the two random polygonal chains: closed (left) vs. open (right)</figcaption>
		</figure>
		
		<p>This means that, in the <code>&lt;polygon&gt;</code> case, the value of the sweep flag <code><var>f<sub>i</sub></var></code> depends on the coordinate differences <code>d<sub>i</sub></code> (between vertex <code>i+1</code> and vertex <code>i</code>) and <code>d<sub>i-1</sub></code> (between vertex <code>i</code> and vertex <code>i-1</code>):</p>
		
		<pre><var>f<sub>i</sub></var> = fn(d<sub>i</sub>, d<sub>i-1</sub>)</pre>
		
		<p>However, in the <code>&lt;polyline&gt;</code> case, the value of the sweep flag <code><var>f<sub>i</sub></var></code> depends on the coordinate differences <code>d<sub>i+1</sub></code> (between vertex <code>i+2</code> and vertex <code>i+1</code>) and <code>d<sub>i</sub></code> (between vertex <code>i+1</code> and vertex <code>i</code>):</p>
		
		<pre><var>f<sub>i</sub></var> = fn(d<sub>i+1</sub>, d<sub>i</sub>)</pre>
		
		<figure>
			<img src='images/sweep_f_diagr.svg' alt='diagram showing how getting sweep flags from vertex coordinates works in the two cases: polygon vs. polyline'/>
			<figcaption>diagram showing how getting sweep flags from vertex coordinates works in the two cases: <code>&lt;polygon&gt;</code> (top) vs. <code>&lt;polyline&gt;</code> (bottom)</figcaption>
		</figure>
		
		<p>If <code>τ</code> is the type of polygonal chain (<code>0</code> when closed vs. <code>1</code> when open), then the two can be unified:</p>
		
		<pre><var>f<sub>i</sub></var> = fn(d<sub>i+τ</sub>, d<sub>i-1+τ</sub>)</pre>
		
		<p>In the <code>&lt;polygon&gt;</code> case, both the index of the current arc and of the coordinate differences corresponding to the edge after the vertex the arc replaces (edge <code>i</code>) go from <code>0</code> all the way through <code>n-1</code> (<code>0 &le; i &lt; n</code>). But in the <code>&lt;polyline&gt;</code> case, the index of the current arc goes from <code>0</code> through <code>n-3</code> (<code>0 &le; i &lt; n-2</code>), while that of the coordinate differences corresponding to the edge after the vertex the arc replaces (edge <code>i+1</code>) goes from <code>1</code> through <code>n-2</code> (<code>1 &le; i &lt; n-1</code>).</p>
		
		<p>In the unified case, the index of the current arc goes from <code>0</code> through <code>n-1-2·τ</code> (<code>0 &le; i &lt; n-2·τ</code>), while that of the edge after the vertex the current arc replaces goes from <code>τ</code> through <code>n-1-τ</code> (<code>τ &le; i &lt; n-τ</code>).</p>
		
		<p>Now let's code this! What we do here is <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map'><code>map()</code></a> the 2D array of coordinate differences to a 1D array of flags:</p>
		
		<pre>let f = d.slice(τ).map((c, i) => {
	/* coord diffs corresp to previous edge */
	let prv = d[(i + ne - 1 + τ)%ne];

	return .5*(Math.sign(prv[0]*c[1] - c[0]*prv[1]) + 1);
});</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/d71cfc5580d99d1ccbbd67fcf47ee7ae?editors=0011'>This Pen</a> checks that the above bit of JavaScript works as it should.</p>
		
		<h2>start and end points of arcs</h2>
		
		<h3>coordinates for random point in 2D</h3>
		
		<p>Let's take a random point <var>P</var>, whose coordinates <code><var>xp</var>,<var>yp</var></code> we need to compute. We can consider this point to be on a circle of radius <code>r</code>. Its <code><var>xp</var>,<var>yp</var></code> coordinates depend on the radius of the circle and on where it is on the circle. The measure of where it is on the circle is the angle between the radial line <var>OP</var> and the horizontal (the <code><var>x</var></code> axis). The following interactive demo illustrates this (drag point <var>P</var> to see how its coordinates change as the circle radius and the angle of the radial line change):</p>
		
		<p data-height="620" data-theme-id="0" data-slug-hash="KNxXZJ" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="position of point in a plane (drag point)" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/KNxXZJ/">position of point in a plane (drag point)</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
		
		<p>Consider the following particular case:</p>

		<figure>
			<img src='images/pt_coord_pcase.svg' alt='particular case of a point in a plane'/>
			<figcaption>particular case of a point in a plane</figcaption>
		</figure>

		<p>The <var>Q</var> and <var>R</var> points are the projections of our point <var>P</var> onto the axes of our system of coordinates. This means that <var>PQ</var> and <var>PR</var> are perpendicular onto the axes (the <var>∠PQO</var> and <var>∠PRO</var> angles are <code>90°</code> angles). It also means that the <var>OQ</var> and <var>PR</var> segments are equal to <code><var>xp</var></code> (which is the value of <var>P</var>'s <code><var>x</var></code> coordinate) and that the <var>OR</var> and <var>PQ</var> segments are equal to <code><var>yp</var></code> (which is the value of <var>P</var>'s <code><var>y</var></code> coordinate).</p>

		<p><var>PQO</var> is a right triangle (since the <var>∠PQO</var> angle is a <code>90°</code> angle) where we know the hypotenuse <var>OP</var> (it's <code>r</code>, the radius of the circle our point <var>P</var> is on) and the <var>∠QOP</var> angle (it's <code>θ</code>).</p>

		<p>The cosine of the <var>∠QOP</var> angle (<code>θ</code>) is the ratio between the adjacent <a href='https://en.wikipedia.org/wiki/Cathetus'>cathetus</a> <var>OQ</var> (<code><var>xp</var></code>) and the hypotenuse <var>OP</var> (<code>r</code>). This means we have <code>cos(θ) = <var>xp</var>/r</code> and, from here, we get that <code><var>xp</var> = r·cos(θ)</code>.</p>

		<p>Similarly, the sine of the same <var>∠QOP</var> angle (<code>θ</code>) is the ratio between the opposing cathetus <var>PQ</var> (<code><var>yp</var></code>) and the hypotenuse <var>OP</var> (<code>r</code>). This means we have <code>sin(θ) = <var>yp</var>/r</code> and, from here, we get that <code><var>yp</var> = r·sin(θ)</code>.</p>

		<p>So the <code><var>xp</var>,<var>yp</var></code> coordinates of any point <var>P</var> on a circle around the origin are:</p>

		<pre><var>xp</var> = r·cos(θ)
<var>yp</var> = r·sin(θ)</pre>

		<p>Here, <code>r</code> is the radius of the circle and <code>α</code> is the angle of the radial line connecting the origin to our point <var>P</var> with respect to the horizontal (both are known).</p>
		
		<p>But what about the case when this circle's central point doesn't coincide with the <code>0,0</code> point of the coordinate system? Well, in this case, we need to add up the coordinates of the circle's central point:</p>

		<pre><var>xp</var> = xo + r·cos(θ)
<var>yp</var> = yo + r·sin(θ)</pre>
		
		<figure>
			<img src='images/pt_coord_pcase_off.svg' alt='particular case of a point in a plane when the central point of the circle it is on is not at the (0,0) point of the coordinate system'/>
			<figcaption>particular case of a point in a plane when the central point of the circle it's on is not at the <code>0,0</code> point of the coordinate system</figcaption>
		</figure>
		
		<p>This is the situation we're actually interested in because what we do here is take the start and end points of our arcs as being on circles whose central points are the corner points of our initial polygonal chain.</p>
		
		<p>Let's consider first the start points:</p>
		
		<figure>
			<img src='images/arc_s_on_circ_base.svg' alt='start points of arcs relative to vertices of initial polygonal chain'/>
			<figcaption>start points of arcs relative to vertices of initial polygonal chain</figcaption>
		</figure>

		<p>So for arc <code>i</code>, the coordinates of its start point can be computed from the <code>x<sub>i+τ</sub>,y<sub>i+τ</sub></code> coordinates of the the polygonal chain vertex that's being replaced by this arc <var>A<sub>i+τ</sub></var> (<var>A<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case when <code>τ = 0</code> and <var>A<sub>i+1</sub></var> in the <code>&lt;polyline&gt;</code> case when <code>τ = 1</code>), the radius <var>A<sub>i+τ</sub>S<sub>i</sub></var> (<var>A<sub>i</sub>S<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case when <code>τ = 0</code> and <var>A<sub>i+1</sub>S<sub>i</sub></var> in the <code>&lt;polyline&gt;</code> case when <code>τ = 1</code>) of this circle and the angle of the radial segment <var>A<sub>i+τ</sub>S<sub>i</sub></var> with respect to the horizontal.</p>
		
		<p>We already know all vertex coordinates, so what we still need to get are the <var>A<sub>i+τ</sub>S<sub>i</sub></var> radii and the angles between the horizontal and these radial lines.</p>
		
		<p>Now let's see the end points:</p>
		
		<figure>
			<img src='images/arc_e_on_circ_base.svg' alt='end points of arcs relative to vertices of initial polygonal chain'/>
			<figcaption>end points of arcs relative to vertices of initial polygonal chain</figcaption>
		</figure>
		
		<p>For arc <code>i</code>, the coordinates of its end point can be computed from the <code>x<sub>i+τ</sub>,y<sub>i+τ</sub></code> coordinates of the the polygonal chain vertex that's being replaced by this arc <var>A<sub>i+τ</sub></var> (<var>A<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case when <code>τ = 0</code> and <var>A<sub>i+1</sub></var> in the <code>&lt;polyline&gt;</code> case when <code>τ = 1</code>), the radius <var>A<sub>i+τ</sub>E<sub>i</sub></var> (<var>A<sub>i</sub>E<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case when <code>τ = 0</code> and <var>A<sub>i+1</sub>E<sub>i</sub></var> in the <code>&lt;polyline&gt;</code> case when <code>τ = 1</code>) of this circle and the angle of the radial segment <var>A<sub>i+τ</sub>E<sub>i</sub></var> with respect to the horizontal.</p>
		
		<p>Just like in the start point case, what we still need to compute are the <var>A<sub>i+τ</sub>E<sub>i</sub></var> radii and the angles between the horizontal and these radial lines.</p>
		
		<h3>segments connecting replaced vertices to start and end points of corresponding arcs</h3>
		
		<p>Every one of our rounding arcs is a part (less than half) of a circle of radius <code>R</code>. This is the rounding radius, which is known, we've read it from the <code>r</code> attribute on our <code>&lt;polygon&gt;</code> or <code>&lt;polyline&gt;</code> element.</p>
		
		<figure>
			<img src='images/arc_circ.svg' alt='each rounding arc is a part of a circle of radius R' />
			<figcaption>each rounding arc is a part of a circle of radius <code>R</code></figcaption>
		</figure>
		
		<p>The start and end points of an arc are the points where the two consecutive edges of our initial polygon that form the angle we want to replace with this arc <em>touch</em> the circle of radius <code>R</code> (placed inside the angle) that the rounding arc belongs to. This means that these edges are <a href='https://en.wikipedia.org/wiki/Tangent_lines_to_circles'>tangent</a> to this circle at the start and end point of the arc. A radial segment to the point where a tangent line touches the circle is perpendicular onto that tangent line.</p>

		<figure>
			<img src='images/arc_tan.svg' alt='the edges meeting at the vertex replaced by arc i (which is vertex i if the polygonal chain is closed and vertex i+1 if the polygonal chain is open) are tangent to the circle this arc is a part of' />
			<figcaption>the edges meeting at the vertex replaced by arc <code>i</code> (which is vertex <code>i</code> if the polygonal chain is closed and vertex <code>i+1</code> if the polygonal chain is open) are tangent to the circle this arc is a part of</figcaption>
		</figure>
		
		<p>This means that the <var>A<sub>i+τ</sub>O<sub>i</sub>S<sub>i</sub></var> (<var>A<sub>i</sub>O<sub>i</sub>S<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case and <var>A<sub>i+1</sub>O<sub>i</sub>S<sub>i</sub></var> in the <code>&lt;polyline&gt;</code> case) and <var>A<sub>i+τ</sub>O<sub>i</sub>E<sub>i</sub></var> (<var>A<sub>i</sub>O<sub>i</sub>E<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case and <var>A<sub>i+1</sub>O<sub>i</sub>E<sub>i</sub></var> in the <code>&lt;polyline&gt;</code> case) triangles are right triangles.</p>
		
		<p>Furthermore, they have the same hypotenuse <var>A<sub>i+τ</sub>O<sub>i</sub></var> and their <var>O<sub>i</sub>S<sub>i</sub></var> and <var>O<sub>i</sub>E<sub>i</sub></var> catheti are equal (as they're both radial segments - <code>R</code>). This makes our two right triangles <a href='https://en.wikipedia.org/wiki/Congruence_(geometry)#Congruence_of_triangles'>congruent</a>, meaning that their <var>A<sub>i+τ</sub>S<sub>i</sub></var> and <var>A<sub>i+τ</sub>E<sub>i</sub></var> edges are also equal and that the acute angles <var>∠O<sub>i</sub>A<sub>i+τ</sub>S<sub>i</sub></var> and <var>∠O<sub>i</sub>A<sub>i+τ</sub>E<sub>i</sub></var> are equal.</p>

		<figure>
			<img src='images/arc_tri.svg' alt='at the vertex replaced by arc i we have two congruent right triangles with a common hypotenuse'/>
			<figcaption>the vertex replaced by arc <code>i</code>: the <var>A<sub>i+τ</sub>O<sub>i</sub>S<sub>i</sub></var> and <var>A<sub>i+τ</sub>O<sub>i</sub>E<sub>i</sub></var> triangles are congruent right triangles with a common hypotenuse</figcaption>
		</figure>
		
		<p>This is really useful.</p>

		<p>First of all, it means that the <var>A<sub>i+τ</sub>O<sub>i</sub></var> line (<var>A<sub>i</sub>O<sub>i</sub></var> if the polygonal chain is closed and <var>A<sub>i+1</sub>O<sub>i</sub></var> if the polygonal chain is open) is the <a href='https://en.wikipedia.org/wiki/Bisection#Angle_bisector'>angle bisector</a> of the <var>∠A<sub>i-1+τ</sub>A<sub>i+τ</sub>A<sub>i+1+τ</sub></var> angle, which we have already computed, it's <code>α<sub>i</sub></code>. Consequently, we can easily get the <var>∠O<sub>i</sub>A<sub>i+τ</sub>S<sub>i</sub></var> and <var>∠O<sub>i</sub>A<sub>i+τ</sub>E<sub>i</sub></var> angles - they're half of the already computed <var>∠A<sub>i-1+τ</sub>A<sub>i+τ</sub>A<sub>i+1+τ</sub></var>, which makes each one of them <code>α<sub>i</sub>/2</code>.</p>
		
		<p>It also means that we need to compute <var>A<sub>i+τ</sub>S<sub>i</sub></var>. <var>A<sub>i+τ</sub>E<sub>i</sub></var> has the exact same length, which we denote by <code><var>ρ<sub>i</sub></var></code>. We can compute this from the right triangle <var>A<sub>i+τ</sub>O<sub>i</sub>S<sub>i</sub></var>. The tangent of the <var>∠O<sub>i</sub>A<sub>i+τ</sub>S<sub>i</sub></var> angle (<code>α<sub>i</sub>/2</code>) is the opposing cathetus <var>O<sub>i</sub>S<sub>i</sub></var> (<code>R</code>) over the adjacent one <var>A<sub>i+τ</sub>S<sub>i</sub></var> (<code><var>ρ<sub>i</sub></var></code>):</p>
		
		<pre>tan(α<sub>i</sub>/2) = R/<var>ρ<sub>i</sub></var></pre>
		
		<p>This gives us the radial segment <var>A<sub>i+τ</sub>S<sub>i</sub></var>:</p>
		
		<pre><var>ρ<sub>i</sub></var> = R/tan(α<sub>i</sub>/2)</pre>
		
		<p>Translating this into JavaScript code, we have:</p>
		
		<pre>let ρ = α.map(c => R/Math.tan(.5*c))</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/418d9601fd610e1a73312ad3150fe95a?editors=0011'>Test</a>.</p>
		
		<h3>angles between horizontal and segments connecting replaced vertices to arc start/ end points</h3>
		
		<p>Let's see the angles of the segments connecting the replaced vertices (<code>τ</code>, .... <code>i-1</code>, <code>i</code>, <code>i+1</code>, ... <code>n-1-τ</code>, where <code>τ</code> is <code>0</code> if the polygonal chain is closed and <code>1</code> otherwise) to the start points:</p>
		
		<figure>
			<img src='images/arc_s_on_circ_meas.svg' alt='angles of radial segments to arc start points with respect to the horizontal'/>
			<figcaption>angles of radial segments <var>A<sub>i+τ</sub>S<sub>i</sub></var> with respect to the horizontal</figcaption>
		</figure>
				
		<p>Since the <var>S<sub>i</sub></var> points are on the <var>A<sub>i+τ</sub>A<sub>i-1+τ</sub></var> segments (<var>A<sub>i</sub>A<sub>i-1</sub></var> in the <code>&lt;polygon&gt;</code> case when <code>τ = 0</code> and <var>A<sub>i+1</sub>A<sub>i</sub></var> in the <code>&lt;polyline&gt;</code> case when <code>τ = 1</code>), the angles of the <var>A<sub>i+τ</sub>S<sub>i</sub></var> radii with respect to the horizontal are the angles between the horizontal and these <var>A<sub>i+τ</sub>A<sub>i-1+τ</sub></var> segments (which are edges of our initial polygonal chain).</p>
		
		<p>So the angles we want are the angles formed at every vertex between the horizontal and the edge <em>before</em> that vertex. That's if there is an edge before that vertex because, in the case when the polygonal chain is open, we don't have an edge before the first vertex <var>A<sub>0</sub></var>.</p>
		
		<p>The array of <code><var>δ</var></code> angles we need to get is an edge-related variable - we compute one angle for each edge of the polygonal chain, so we have one less angle computation to do in the <code>&lt;polyline&gt;</code> case (because we have one less edge in this situation).</p>
		
		<p>Also, in the <code>&lt;polyline&gt;</code> case, we only use the first <code>n-2</code> of these angles. We don't need <code><var>δ<sub>n-2</sub></var></code> in this situation since this is the angle of the <var>A<sub>n-1</sub>A<sub>n-2</sub></var> edge and we don't have a start point of an arc on that edge, only the end point of the last arc (arc <code>n-3</code>, replacing vertex <code>n-2</code>) and this arc end point is then connected to the end point of the polyline, last vertex <var>A<sub>n-1</sub></var>.</p>
		
		<p>Moving on to the endpoints, we can see the angles marked on the following figure:</p>
		
		<figure>
			<img src='images/arc_e_on_circ_meas.svg' alt='angles of radial segments to arc end points with respect to the horizontal'/>
			<figcaption>angles of radial segments <var>A<sub>i+τ</sub>E<sub>i</sub></var> with respect to the horizontal</figcaption>
		</figure>
		
		<p>Since the <var>E<sub>i</sub></var> points are on the <var>A<sub>i+τ</sub>A<sub>i+1+τ</sub></var> segments (<var>A<sub>i</sub>A<sub>i+1</sub></var> in the <code>&lt;polygon&gt;</code> case when <code>τ = 0</code> and <var>A<sub>i+1</sub>A<sub>i+2</sub></var> in the <code>&lt;polyline&gt;</code> case when <code>τ = 1</code>), the angles of the <var>A<sub>i+τ</sub>E<sub>i</sub></var> radii with respect to the horizontal are the angles between the horizontal and the <var>A<sub>i+τ</sub>A<sub>i+1+τ</sub></var> edges of our initial polygonal chain.</p>
		
		<p>In this case, the angles we want are the angles formed at every vertex between the horizontal and the edge <em>after</em> that vertex. Again, that's only if there is an edge after that vertex because, in the case when the polygonal chain is open, we don't have an edge after the last vertex <var>A<sub>n-1</sub></var>.</p>
		
		<p>The array of <code><var>γ</var></code> angles we need to get here is also an edge-related variable - we compute one angle for each edge of the polygonal chain, so we have one less angle computation to do in the <code>&lt;polyline&gt;</code> case since we don't connect the last vertex to the first one in this situation.</p>
		
		<p>Since the array of edge angles <code><var>γ</var></code> is edge-related, but the array where we store the coordinates of the arcs' endpoints is corner-related, this means that, in the <code>&lt;polyline&gt;</code> case, we only use the last <code>n-2</code> of the edge angles. We don't need <code><var>γ<sub>0</sub></var></code> in this situation since this is the angle of the <var>A<sub>0</sub>A<sub>1</sub></var> edge and we don't have an end point of an arc on that edge, only the start point of the first arc (arc <code>0</code>, replacing vertex <code>1</code>), which is connected to the start point of the polyline, first vertex <var>A<sub>0</sub></var>.</p>
		
		<p>A very important thing to notice from the previous two illustrations is that <code><var>γ<sub>i</sub></var></code> (the angle between the horizontal and the <var>A<sub>i</sub>A<sub>i+1</sub></var> segment) and <code><var>δ<sub>i</sub></var></code> (the angle between the horizontal and the <var>A<sub>i+1</sub>A<sub>i</sub></var> segment, which is basically the same segment as <var>A<sub>i</sub>A<sub>i+1</sub></var>, only going in the other direction) are <a href='https://en.wikipedia.org/wiki/Transversal_(geometry)#Consecutive_interior_angles'>consecutive interior angles</a> (because all horizontal lines are parallel with one another) and therefore, their absolute values add up to <code>180°</code> (which makes them <a href='https://en.wikipedia.org/wiki/Angle#Supplementary_angle'>supplementary</a>).</p>
		
		<figure>
			<img src='images/edge_arcs.svg' alt='angles γi and δi'/>
			<figcaption>angles <code><var>γ<sub>i</sub></var></code> and <code><var>δ<sub>i</sub></var></code></figcaption>
		</figure>
		
		<p>If we also take into account their signs (one goes clockwise, so its sign is <code>+</code>, the other one goes in the opposite direction, so its sign is <code>-</code>), we see that they are <code>180°</code> apart. Subtracting <code>180°</code> from the positive one gives us the negative one, while adding <code>180°</code> to the negative one gives us the positive one.</p>
		
		<!--<p>If we draw another horizontal line through the middle of our <var>A<sub>i</sub>A<sub>i+1</sub></var></code> segment, we create <a href='https://en.wikipedia.org/wiki/Transversal_(geometry)#Corresponding_angles'>corresponding angles</a>:</p>
		
		<figure>
			<img src='' alt=''/>
			<figcaption>ILLUSTRATIONNNNNNNNNNNNN</figcaption>
		</figure>-->
		
		<p>The interactive demo below illustrates this. Drag the <var>A<sub>i</sub>A<sub>i+1</sub></var> segment to see how its angle with respect the horizontal (<code>γ<sub>i</sub></code>, marked with pink) changes and how that influences the angle of <var>A<sub>i+1</sub>A<sub>i</sub></var> with respect to the horizontal (<code>δ<sub>i</sub></code>, marked with green).</p>
		
		<p data-height="630" data-theme-id="0" data-slug-hash="eBaRVV" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="angles of a segment w.r.t. the horizontal (SVG + JS)" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/eBaRVV/">angles of a segment w.r.t. the horizontal (SVG + JS)</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
		
		<p>Knowing that we have this relation between the two means that, if we get <code><var>γ<sub>i</sub></var></code>, then we can easily get <code><var>δ<sub>i</sub></var></code> as well.</p>
		
		<p>In order to compute <code><var>γ<sub>i</sub></var></code>, let's get back to our right triangle <var>A<sub>i</sub>T<sub>i+1</sub>A<sub>i+1</sub></var>:</p>
		
		<figure>
			<img src='images/edge_right_tri_ang.svg' alt='getting γi from a right triangle'/>
			<figcaption><code><var>γ<sub>i</sub></var></code> in the right triangle <var>A<sub>i</sub>T<sub>i+1</sub>A<sub>i+1</sub></var></figcaption>
		</figure>
		
		<p>In this right triangle, the tangent of the <var>∠T<sub>i+1</sub>A<sub>i</sub>A<sub>i+1</sub></var> angle (<code><var>γ<sub>i</sub></var></code>) is the ratio between the opposing cathetus <var>T<sub>i+1</sub>A<sub>i+1</sub></var> (<code>dy<sub>i</sub></code>) and the adjacent cathetus <var>A<sub>i</sub>T<sub>i+1</sub></var> (<code>dx<sub>i</sub></code>).</p>
		
		<pre>tan(<var>γ<sub>i</sub></var>) = dy<sub>i</sub>/dx<sub>i</sub></pre>
		
		<p>This means that we can get this angle <code><var>γ<sub>i</sub></var></code> (which is also the angle of the <var>A<sub>i</sub>A<sub>i+1</sub></var> edge) from the values of the <code>dx<sub>i</sub></code> and <code>dy<sub>i</sub></code> differences that we now know (the <code>d</code> array) using <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2'><code>Math.atan2()</code></a>:</p>
		
		<pre>let γ = d.map(c => Math.atan2(...c.reverse()));</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/89bd96f8a280bfaeaa64011a8219717b?editors=0011'>This pen</a> checks that we got the correct values this way.</p>
		
		<p class='note'>The <code>reverse()</code> function mutates the array, but that's exactly what we want here since we won't need the pairs of coordinates in the <code>dx,dy</code> order again anyway (only in the <code>dy,dx</code> order we have them now after reversing them, but we'll get to that soon).</p>
		
		<p>In general, the tangent of an angle between the horizontal and a segment (doesn't matter whether this angle is acute, obtuse, positive, negative) is the ratio between the oriented projections of this segment onto the vertical and horizontal lines passing through the start point of this segment. The figure below illustrates this for the <code><var>γ<sub>i</sub></var></code> angle of the <var>A<sub>i</sub>A<sub>i+1</sub></var> segment with respect to the horizontal.</p>
		
		<figure>
			<img src='images/edge_orient_proj_dir.svg' alt=''/>
			<figcaption>the oriented projections of the <var>A<sub>i</sub>A<sub>i+1</sub></var> segment</figcaption>
		</figure>
		
		<p>Now let's see how things look in the case of the <code><var>δ<sub>i</sub></var></code> angle of the <var>A<sub>i+1</sub>A<sub>i</sub></var> segment with respect to the horizontal.</p>
		
		<figure>
			<img src='images/edge_orient_proj_rev.svg' alt=''/>
			<figcaption>the oriented projections of <var>A<sub>i+1</sub>A<sub>i</sub></var> compared to <var>A<sub>i</sub>A<sub>i+1</sub></var></figcaption>
		</figure>
		
		<p>In this case, the projections are oriented in the opposite direction, which gives us that the tangent of the angle <code><var>δ<sub>i</sub></var></code> between the horizontal and the <var>A<sub>i+1</sub>A<sub>i</sub></var> segment is the ratio between <code>-dy<sub>i</sub></code> and <code>-dx<sub>i</sub></code>:</p>
		
		<pre>tan(<var>δ<sub>i</sub></var>) = -dy<sub>i</sub>/-dx<sub>i</sub></pre>
		
		<p>Wait a second, that's the same ratio as before because the minus signs cancel each other! Does that mean we get the same angle as before and wouldn't that be wrong since <code><var>γ<sub>i</sub></var></code> and <code><var>δ<sub>i</sub></var></code> must have opposite signs? Well, while the ratio is the same, the oriented projections have different signs, so we don't get the same angle if we compute it with the <code>Math.atan2()</code> function, which takes these projections as separate arguments (and not just the ratio as one argument the way <code>Math.atan()</code> does):</p>
		
		<pre>let δ = d.map(c => Math.atan2(...c.map(c => -c)));</pre>
		
		<p>Note that now we didn't need to reverse the pairs of coordinate differences because we've already done that when we computed the <code>γ</code> array.</p>
		
		<p><a href='https://codepen.io/thebabydino/pen/dc5a81d05905ae7119fcdbc8e9aeb37e?editors=0011'>This Pen</a> checks that the angles we got look right.</p>
		
		<h3>coordinates for start and end points of arcs</h3>
		
		<p>And we're finally here! The following figure illustrates how we compute the coordinates of the start point of our arcs:</p>
		
		<figure>
			<img src='images/arc_s_comp.svg' alt=''/>
			<figcaption>how to get the coordinates of the start points of our arcs</figcaption>
		</figure>

		<p>There's a lot going on in the above illustration, but the main idea is that we get the coordinates of start point <var>S<sub>i</sub></var> from those of the original vertex that the arc it starts (arc <code>i</code>) replaces, which is vertex <var>A<sub>i+τ</sub></var> (<var>A<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case and <var>A<sub>i+1</sub></var> in the <code>&lt;polyline&gt;</code> case), from the length of the <var>A<sub>i+τ</sub>S<sub>i</sub></var> segment (<code>ρ<sub>i</sub></code>) and from the angle of this segment with respect to the horizontal (<code>δ<sub>i-1+τ</sub></code>):</p>

		<pre><var>xs<sub>i</sub></var> = x<sub>i+τ</sub> + ρ<sub>i</sub>·cos(δ<sub>i-1+τ</sub>)
<var>ys<sub>i</sub></var> = y<sub>i+τ</sub> + ρ<sub>i</sub>·sin(δ<sub>i-1+τ</sub>)</pre>

		<p>Putting this into JavaScript code, we have:</p>

		<pre>let s = ρ.map((c, i) => {
	let x = v[i + τ][0] + c*Math.cos(δ[(i - 1 + τ + ne)%ne]), 
		y = v[i + τ][1] + c*Math.sin(δ[(i - 1 + τ + ne)%ne]);
	
	return [x, y];
});</pre>

		<p>The above code <a href='https://codepen.io/thebabydino/pen/eb90c6583973522609dcc3bdc0782cf1?editors=0011'>works</a>, but it's a bit repetitive, so let's <a href='https://codepen.io/thebabydino/pen/664ac53caa5cb39290ca05636de3e25c?editors=0011'>iron that out</a>:</p>

		<pre>const HF = ['cos', 'sin'];

let s = ρ.map((c, i) => 
			  v[i + τ].map((k, j) => 
			  			   k + c*Math[HF[j]](δ[(i - 1 + τ + ne)%ne)));</pre>
		
		<p>Now let's move on to the end points. The following illustration shows how their coordinates can be computed:</p>

		<figure>
			<img src='images/arc_e_comp.svg' alt=''/>
			<figcaption>how to get the coordinates of the end points of our arcs</figcaption>
		</figure>

		<p>For arc <code>i</code>, we get the coordinates of end point <var>E<sub>i</sub></var> from those of the original vertex that the arc it ends replaces, which is vertex <var>A<sub>i+τ</sub></var> (<var>A<sub>i</sub></var> in the <code>&lt;polygon&gt;</code> case and <var>A<sub>i+1</sub></var> in the <code>&lt;polyline&gt;</code> case), from the length of the <var>A<sub>i+τ</sub>E<sub>i</sub></var> segment (<code>ρ<sub>i</sub></code>) and from the angle of this segment with respect to the horizontal (<code>γ<sub>i+τ</sub></code>):</p>

		<pre><var>xe<sub>i</sub></var> = x<sub>i+τ</sub> + ρ<sub>i</sub>·cos(γ<sub>i+τ</sub>)
<var>ye<sub>i</sub></var> = y<sub>i+τ</sub> + ρ<sub>i</sub>·sin(γ<sub>i+τ</sub>)</pre>

		<p>This means we have the following JavaScript code to <a href='https://codepen.io/thebabydino/pen/5556496a29163ce8d0ef4138e4bc56d1?editors=0011'>compute these coordinates</a>:</p>

		<pre>let e = ρ.map((c, i) => 
			  v[i + τ].map((k, j) => 
			  			   k + c*Math[HF[j]](γ[(i + τ + ne)%ne)));</pre>
		
		<h2>creating the path data</h2>

		<p>Now that we have all we need in order to generate our path data, let's see how we do that.</p>

		<figure>
			<img src='images/path_equiv_rnd.svg' alt=''/>
			<figcaption>equivalent paths vs. original polygonal chains</figcaption>
		</figure>

		<p>If our polygonal chain is closed, then our path data looks something like this:</p>

		<pre><strong>M</strong> <strong>xs<sub>0</sub>, ys<sub>0</sub>
A R, R, , 0, 0, f<sub>0</sub>, xe<sub>0</sub>, ye<sub>0</sub>
...
L xs<sub>i</sub>, ys<sub>i</sub>
A R, R, , 0, 0, f<sub>i</sub>, xe<sub>i</sub>, ye<sub>i</sub>
...
L xs<sub>n-1</sub>, ys<sub>n-1</sub>
A R, R, , 0, 0, f<sub>n-1</sub>, xe<sub>n-1</sub>, ye<sub>n-1</sub></strong>
z</pre>
		
		<p>However, if our polygonal chain is open, things change a bit:</p>
		
		<pre><strong>M</strong> x<sub>0</sub>, y<sub>0</sub>
L <strong>xs<sub>0</sub>, ys<sub>0</sub>
A R, R, , 0, 0, f<sub>0</sub>, xe<sub>0</sub>, ye<sub>0</sub>
...
L xs<sub>i</sub>, ys<sub>i</sub>
A R, R, , 0, 0, f<sub>i</sub>, xe<sub>i</sub>, ye<sub>i</sub>
...
L xs<sub>n-3</sub>, ys<sub>n-3</sub>
A R, R, , 0, 0, f<sub>n-3</sub>, xe<sub>n-3</sub>, ye<sub>n-3</sub></strong>
L x<sub>n-1</sub>, y<sub>n-1</sub></pre>

		<p>In both cases, we start with a "move to" (<code>M</code>) command.</p>

		<p>In the <code>&lt;polygon&gt;</code> case, we go straight to the start point of the first arc (<code>xs<sub>0</sub>,ys<sub>0</sub></code>). In the <code>&lt;polyline&gt;</code> case, we go to the first vertex of our original polygon (<code>x<sub>0</sub>,y<sub>0</sub></code>) and from there, using the "line to" (<code>L</code>) command, we draw a line to the start point of the first arc (<code>xs<sub>0</sub>,ys<sub>0</sub></code>).</p>

		<p>From this point on, we have a big chunk that's a gain common drawing all the arcs of our equivalent path (<code>n</code> of them in the <code>&lt;polygon&gt;</code> case and <code>n-2</code> in the <code>&lt;polyline&gt;</code> case) and connecting these arcs with straight lines (from the end point of one to the start point of the next).</p>

		<p>From the end point of the last arc of our equivalent path (<code>xe<sub>n-1</sub>,ye<sub>n-1</sub></code> if the polygonal chain is closed and <code>xe<sub>n-3</sub>,ye<sub>n-3</sub></code> if it's open) things are again a bit different. In the <code>&lt;polygon&gt;</code> case, we just close the path (the <code>z</code> command). In the <code>&lt;polyline&gt;</code> case, we go to the last vertex of our original polygon (<code>x<sub>n-1</sub>,y<sub>n-1</sub></code>) and we don't close the path.</p>

		<p>So the JavaScript code that generates our path data is:</p>

		<pre>/* number of angles of original polygonal chain */
let na = n - 2*τ;

/* the path data */
let pd = `M${τ ? v[0] + 'L' : ''}`;

for(let i = 0; i < na; i++) {
	pd += `${i ? 'L' : ''}${s[i]}A${[R, R, 0, 0, f[i], e[i]]}`;
}

pd += τ ? `L${v[n - 1]}` : 'z';
		</pre>

		<p>However, just generating this path data doesn't do anything. We need to create a <code>&lt;path&gt;</code> element, append it right next to our initial polygonal chain and set this path data to its <code>d</code> attribute.</p>

		<pre>const NS_URI = 'http://www.w3.org/2000/svg';

let _path = document.createElementNS(NS_URI, 'path');
_path.setAttribute('d', pd);
	
let _up = _poly.parentNode;
_up.insertBefore(_path, _poly);
</pre>

		<p>The initial polygonal chain element and this <code>&lt;path&gt;</code> element are one on top of each other, so we tweak the <code>opacity</code> of the polygonal chain in the CSS and set a few very obvious styles for the <code>&lt;path&gt;</code> to check that everything looks right:</p>
		
		<pre>[points] { opacity: .35 }

path {
	fill: none;
	stroke: #ef9134
}</pre>
		
		<p>Looks like we're almost done!</p>
		
		<p data-height="400" data-theme-id="0" data-slug-hash="634638a63bd469abb3d3a83a93e52074" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="[NMAR] round poly(gon|line) corners - fillet step #15" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/634638a63bd469abb3d3a83a93e52074/">[NMAR] round poly(gon|line) corners - fillet step #15</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

		<p>Now the question is: can we be sure it works in all situations? Let's see some more random polygonal chains:</p>

		<p data-height="570" data-theme-id="0" data-slug-hash="3da6186b5b9c2e8d1b1972128e905567" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="[NMAR] round poly(gon|line) corners - fillet step #16" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/3da6186b5b9c2e8d1b1972128e905567/">[NMAR] round poly(gon|line) corners - fillet step #16</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

		<p>It looks like it works for a lot of types of random polygonal chains, so can there still be a situation when it fails?</p>
		
		<p>Sadly, yes, so we're not done yet!</p>

		<h2>the big radius problem</h2>
		
		<p>Let's consider the original SVG code we had for our first test polygon (the equilateral triangle) and let's increase the rounding radius (<code>r</code> attribute) to something like <code>35</code> or <code>59</code> or anything a lot larger than our initial value of <code>10</code>. Now the result doesn't look right anymore and the same happens for other polygonal chains when we increase their rounding radii beyond a certain value.</p>

		<p data-height="401" data-theme-id="0" data-slug-hash="47921cf590e6678bcc40db2f836fa56c" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="[NMAR] round poly(gon|line) corners - fillet step #17" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/47921cf590e6678bcc40db2f836fa56c/">[NMAR] round poly(gon|line) corners - fillet step #17</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

		<p>The problem here is the rounding radius being too big for at least one edge (or that edge being too short for the rounding radius, same thing).</p>
		
		<p>Consider edge <code>i</code> being too short. This makes the end point (<var>E<sub>i-τ</sub></var>) of the arc replacing the vertex our too short edge starts from (<var>A<sub>i</sub></var>) end up after the start point (<var>S<sub>i-τ+1</sub></var>) of the arc replacing the vertex the same edge ends at (<var>A<sub>i+1</sub></var>).</p>

		<figure>
			<img src='images/edge_i_short.svg' alt=''/>
			<figcaption>edge <code>i</code> is too short for the rounding radius given by the <code>r</code> attribute, which puts <var>S<sub>i-τ+1</sub></var> behind <var>E<sub>i-τ</sub></var> in going from <var>A<sub>i</sub></var> to <var>A<sub>i+1</sub></var></figcaption>
		</figure>

		<p>So if edge <code>i</code> (<var>A<sub>i</sub>A<sub>i+1</sub></var>) is too short, then in going from the end point of arc <code>i-τ</code> (<var>E<sub>i-τ</sub></var>) to the start point of arc <code>i-τ+1</code> (<var>S<sub>i-τ+1</sub></var>), we actually go backwards on this edge, towards its start point (<var>A<sub>i</sub></var>), not towards its end point (<var>A<sub>i+1</sub></var>) as we should.</p>
		
		<p>The fix is to decrease the radii of the arcs replacing the vertices this edge <code>i</code> connects until <var>S<sub>i-τ+1</sub></var> isn't behind <var>E<sub>i-τ</sub></var> anymore. This happens when <var>S<sub>i-τ+1</sub></var> and <var>E<sub>i-τ</sub></var> overlap, which means stopping when the sum of the <var>A<sub>i</sub>E<sub>i-τ</sub></var> and <var>S<sub>i-τ+1</sub>A<sub>i+1</sub></var> segments equals <var>A<sub>i</sub>A<sub>i+1</sub></var>.</p>

		DEMO
		
		<p class='note'>An important thing to notice is that, in doing this, no angles change. The only things changing are the dimensions of the triangles formed between the initial polygon edges, the arc radii that are perpendicular onto these edges and the segments connecting the original vertices to the central points of the arcs - it's like these triangles get scaled down with respect to the <var>A<sub>i</sub></var> points.</p>
		
		<figure>
			<img src='images/edge_i_lim_vs_ini.svg' alt='' />
			<figcaption>limit radius situation (solid) vs. initial one (dashed and faded) for edge <code>i</code></figcaption>
		</figure>

		<p>In order to keep things simple, we scale everything by the same factor, which means that the radii of both arc <code>i-τ</code> and <code>i-τ+1</code> remain equal to each other throughout the scaling process. We call the radius value for which the end point of arc <code>i-τ</code> (<var>E<sub>i-τ</sub></var>) coincides with the start point of arc <code>i-τ+1</code> (<var>S<sub>i-τ+1</sub></var>) the <strong>limit radius</strong> we can have for the arcs connected to edge <code>i</code> (<var>A<sub>i</sub>A<sub>i+1</sub></var>). This limit radius is edge-related because we compute one for each edge.</p>

		<p>Now let's consider just the right triangles <var>A<sub>i</sub>O<sub>i-τ</sub>E<sub>i-τ</sub></var> and <var>A<sub>i+1</sub>O<sub>i-τ+1</sub>S<sub>i-τ+1</sub></var> after they've been scaled down.</p>
		
		<figure>
			<img src='images/edge_i_lim_right_tri.svg' alt='' />
			<figcaption>right triangles <var>A<sub>i</sub>O<sub>i-τ</sub>E<sub>i-τ</sub></var> and <var>A<sub>i+1</sub>O<sub>i-τ+1</sub>S<sub>i-τ+1</sub></var> after they've been scaled down</figcaption>
		</figure>

		<p>In the right triangle <var>A<sub>i</sub>O<sub>i-τ</sub>E<sub>i-τ</sub></var>, the tangent of the <var>∠O<sub>i-τ</sub>A<sub>i</sub>E<sub>i-τ</sub></var> angle (<code>α<sub>i-τ</sub>/2</code>) is the opposing cathetus <var>O<sub>i-τ</sub>E<sub>i-τ</sub></var> (which goes from the initial value of the rounding radius <code>R</code> to the limit value of the rounding radius <code><var>m<sub>i</sub></var></code> after scaling down) over the adjacent cathetus <var>A<sub>i</sub>E<sub>i-τ</sub></var>. This means that <var>A<sub>i</sub>E<sub>i-τ</sub></var> is <code><var>m<sub>i</sub></var>/tan(α<sub>i-τ</sub>/2)</code>.</p>

		<p>And in the right triangle <var>A<sub>i+1</sub>O<sub>i-τ+1</sub>S<sub>i-τ+1</sub></var>, the tangent of the <var>∠A<sub>i+1</sub>O<sub>i-τ+1</sub>S<sub>i-τ+1</sub></var> angle (<code>α<sub>i-τ+1</sub>/2</code>) is the opposing cathetus <var>O<sub>i-τ+1</sub>S<sub>i-τ+1</sub></var> (which goes from the initial value of the rounding radius <code>R</code> to the limit value of the rounding radius <code><var>m<sub>i</sub></var></code> after scaling down) over the adjacent cathetus <var>A<sub>i+1</sub>S<sub>i-τ+1</sub></var>. This means that <var>A<sub>i+1</sub>E<sub>i-τ+1</sub></var> is <code><var>m<sub>i</sub></var>/tan(α<sub>i-τ+1</sub>/2)</code>.</p>
		
		<p>This gives us that the sum of the <var>A<sub>i</sub>E<sub>i-τ</sub></var> and <var>A<sub>i+1</sub>S<sub>i-τ+1</sub></var> (or <var>S<sub>i-τ+1</sub>A<sub>i+1</sub></var>, orientation doesn't matter in this case) segments is:</p>
		
		<pre><var>m<sub>i</sub></var>·(1/tan(α<sub>i-τ</sub>/2) + 1/tan(α<sub>i-τ+1</sub>/2))</pre>

		<p>To make things easier for ourselves, let's denote by <code>k</code> the inverses of the tangents of the half vertex angles. This makes the above become:</p>

		<pre><var>m<sub>i</sub></var>·(k<sub>i-τ</sub> + k<sub>i-τ+1</sub>)</pre>

		<p>But the sum of the <var>A<sub>i</sub>E<sub>i-τ</sub></var> and <var>A<sub>i+1</sub>S<sub>i-τ+1</sub></var> segments is also the full edge <var>A<sub>i</sub>A<sub>i+1</sub></var>.</p>

		<p>So this all means that, at the point when we stop scaling down the radius, the <var>A<sub>i</sub>A<sub>i+1</sub></var> segment (<code>l<sub>i</sub></code>) is:</p>
		
		<pre>l<sub>i</sub> = <var>m<sub>i</sub></var>·(k<sub>i-τ</sub> + k<sub>i-τ+1</sub>)</pre>

		<p>This way, we can extract the limit radius <code><var>m<sub>i</sub></var></code>:</p>

		<pre><var>m<sub>i</sub></var> = l<sub>i</sub>/(k<sub>i-τ</sub> + k<sub>i-τ+1</sub>)</pre>

		<p class='note'>Note that, while <code>k</code> is corner-related (as the <code>k</code> values get computed directly from those of the angles at each corner), <code>rl</code> is edge-related - we have one limit radius per edge.</p>

		<p>The first thing we need to do here is compute the <code>k</code> values. This is a corner-related array whose values get computed directly from those of the angles at each corner:</p>

		<pre>let k = α.map(c => 1/Math.tan(.5*c))</pre>

		<p>Before we compute the limit radius for each edge, there's one more thing to keep in mind: the first edge and the last edge in the <code>&lt;polyline&gt;</code> case only get connected to one arc, not two. The start point of the first edge <var>A<sub>0</sub></var> doesn't get replaced by an arc when the polygonal chain is open and neither does the end point of the last edge <var>A<sub>n-1</sub></var>.</p>

		<p>In the <code>&lt;polygon&gt;</code> case, we have that <code><var>m<sub>i</sub></var></code> depends on the length of the edge it corresponds to (<code>l<sub>i</sub></code>) and on the angles at the start (<code>i</code>) and end (<code>i+1</code>) vertices of this edge, more precisely on the <code>k</code> values computed as the inverses of the tangents of half these angles:</p>

		<pre><var>m<sub>i</sub></var> = <var>f</var>(l<sub>i</sub>, k<sub>i</sub>, k<sub>i+1</sub>)</pre>

		<p>In the <code>&lt;polyline&gt;</code> case, we have two particular cases for the first and last edge and a general case:</p>

		<pre>i = 0: <var>m<sub>0</sub></var> = <var>f</var>(l<sub>0</sub>, k<sub>0</sub>)
i = n-2: <var>m<sub>n-2</sub></var> = <var>f</var>(l<sub>n-2</sub>, k<sub>i-3</sub>)
0 < i < n-2: <var>m<sub>i</sub></var> = <var>f</var>(l<sub>i</sub>, k<sub>i-1</sub>, k<sub>i</sub>)</pre>

		<p>This is illustrated by the following diagram:</p>

		<figure>
			<img src='images/lim_rad_diagr.svg' alt='' />
			<figcaption>diagram showing how getting limit radii <code><var>m</var></code> from edge lengths <code>l</code> and vertex angle constants <code>k</code> works in the two cases: <code>&lt;polygon&gt;</code> (top) vs. <code>&lt;polyline&gt;</code> (bottom)</figcaption>
		</figure>

		<p>Let's now take a closer look at how we get the limit radius for the first edge when the polygonal chain is open.</p>

		<figure>
			<img src='images/edge_first_ini_vs_lim_right_tri.svg' alt='' />
			<figcaption>the right triangle <var>A<sub>1</sub>S<sub>0</sub>O<sub>0</sub></var> in the initial case (left, using the radius <code>R</code> set via the <code>r</code> attribute) vs. the limit case (right, after scaling it down with respect to <var>A<sub>1</sub></var> such that <var>S<sub>0</sub></var> coincides with <var>A<sub>0</sub></var>, which means it's not beyond the <var>A<sub>0</sub></var> limit of the <var>A<sub>0</sub>A<sub>1</sub></var> segment anymore)</figcaption>
		</figure>

		<p>When we're in the <code>&lt;polyline&gt;</code> case (<code>τ = 1</code>) and we're at the first edge (<code>i = 0</code>), the limit case is when the start point of the first arc <var>S<sub>0</sub></var> coincides with the first vertex of the polygonal chain <var>A<sub>0</sub></var> or, in other words, when the <var>A<sub>0</sub>A<sub>1</sub></var> segment equals the <var>A<sub>1</sub>S<sub>0</sub></var> segment. Since the length of the <var>A<sub>0</sub>A<sub>1</sub></var> segment is <code>l<sub>0</sub></code> and we can compute that of the <var>A<sub>1</sub>S<sub>0</sub></var> segment as <code><var>m<sub>0</sub></var>/tan(α<sub>0</sub>/2)</code> or <code><var>m<sub>0</sub></var>·k<sub>0</sub></code>, we get that the limit radius in this case is:</p>

		<pre><var>m<sub>0</sub></var> = l<sub>0</sub>/k<sub>0</sub></pre>

		<p>Compared to the general formula <code>l<sub>i</sub>/(k<sub>i-τ</sub> + k<sub>i-τ+1</sub>)</code>, the first term at the denominator (<code>k<sub>i-τ</sub></code>) is missing in this situation where <code>τ = 1</code> and <code>i = 0</code>. This means we can consider we have a <code><var>p</var></code> multiplier in front of this term and this multiplier is <code>0</code> if <code>τ = 1</code> and <code>i = 0</code>, but <code>1</code> in every other situation. Given that <code>τ</code> can be either <code>0</code> (for <code>&lt;polygon&gt;</code> elements) or <code>1</code> (for <code>&lt;polyline&gt;</code>) and that <code>i</code> can be any natural number smaller than the number of edges, we can come up with the following formula for <code><var>p</var></code>:</p>

		<pre><var>p</var> = i >= τ</pre>

		<p>This means we now have:</p>

		<pre><var>m<sub>i</sub></var> = l<sub>i</sub>/(<var>p</var>·k<sub>i-τ</sub> + k<sub>i-τ+1</sub>)
<var>p</var> = i >= τ</pre>
		
		<p>Now let's see the limit radius for the last edge when the polygonal chain is open.</p>

		<figure>
			<img src='images/edge_last_ini_vs_lim_right_tri.svg' alt='' />
			<figcaption>the right triangle <var>A<sub>n-2</sub>S<sub>n-3</sub>O<sub>n-3</sub></var> in the initial case (left, using the radius <code>R</code> set via the <code>r</code> attribute) vs. the limit case (right, after scaling it down with respect to <var>A<sub>n-2</sub></var> such that <var>S<sub>n-3</sub></var> coincides with <var>A<sub>n-1</sub></var>, which means it's not beyond the <var>A<sub>n-1</sub></var> limit of the <var>A<sub>n-2</sub>A<sub>n-1</sub></var> segment anymore)</figcaption>
		</figure>

		<p>When we're in the <code>&lt;polyline&gt;</code> case (<code>τ = 1</code>) and we're at the last edge (<code>i = n-2</code>), the limit case is when the end point of the last arc <var>E<sub>n-3</sub></var> coincides with the last vertex of the polygonal chain <var>A<sub>n-1</sub></var> or, in other words, when the <var>A<sub>n-2</sub>A<sub>n-1</sub></var> segment equals the <var>A<sub>n-2</sub>E<sub>n-3</sub></var> segment. Since the length of the <var>A<sub>n-2</sub>A<sub>n-1</sub></var> segment is <code>l<sub>n-2</sub></code> and we can compute that of the <var>A<sub>n-2</sub>E<sub>n-3</sub></var> segment as <code><var>m<sub>n-2</sub></var>/tan(α<sub>n-3</sub>/2)</code> or <code><var>m<sub>n-2</sub></var>·k<sub>n-3</sub></code>, we get that the limit radius in this case is:</p>

		<pre><var>m<sub>n-2</sub></var> = l<sub>n-2</sub>/k<sub>n-3</sub></pre>

		<p>Compared to the general formula <code>l<sub>i</sub>/(k<sub>i-τ</sub> + k<sub>i-τ+1</sub>)</code>, the last term at the denominator (<code>k<sub>i-τ+2</sub></code>) is missing in this situation where <code>τ = 1</code> and <code>i = n-2</code>. This means we can consider we have a <code><var>q</var></code> multiplier in front of this term and this multiplier is <code>0</code> if <code>τ = 1</code> and <code>i = n-2</code>, but <code>1</code> in every other situation. Given that <code>τ</code> can be either <code>0</code> (for <code>&lt;polygon&gt;</code> elements) or <code>1</code> (for <code>&lt;polyline&gt;</code>) and that <code>i</code> can be any natural number smaller than the number of edges (<code>ne = n-τ</code>), we can come up with the following formula for <code><var>q</var></code>:</p>

		<pre><var>q</var> = ne - 1 - i >= τ</pre>

		<p>This means we now have:</p>

		<pre><var>m<sub>i</sub></var> = l<sub>i</sub>/(<var>p</var>·k<sub>i-τ</sub> + <var>q</var>·k<sub>i-τ+1</sub>)
<var>p</var> = i >= τ
<var>q</var> = ne - 1 - i >= τ</pre>

		<p>This way, the JavaScript code for computing the array of limit radii is:</p>

		<pre>let m = l.map((c, i) => 
			c/((i >= τ)*k[(i - τ + na)%na] + (ne - 1 - i >= τ)*k[(i - τ + 1)%na]));</pre>
		
		<p>Now we need to compute one more thing and that's the actual radius we use for every arc. This is the minimum value between the intial rounding radius set via the <code>r</code> attribute and the two limit radii corresponding to the two edges this arc connects.</p>

		<figure>
			<img src='images/rad_pick.svg' alt='' />
			<figcaption>in both the <code>&lt;polygon&gt;</code> case (left) and the <code>&lt;polyline&gt;</code> case (right), the actual rounding radius we use for corner <code>i</code> is the minimum between the initial radius <code>R</code> set via the <code>r</code> attribute and the limit radii we've computed for the edges that meet at this corner: limit radius <code>m<sub>i+τ-1</sub></code> corresponding to edge <code>i+τ-1</code> (<var>A<sub>i+τ-1</sub>A<sub>i+τ</sub></var>) and limit radius <code>m<sub>i+τ</sub></code> corresponding to edge <code>i+τ</code> (<var>A<sub>i+τ</sub>A<sub>i+τ+1</sub></var>)</figcaption>
		</figure>

		<p>If the polygonal chain is closed, then the edges arc <code>i</code> connects are edges <code>i-1</code> and <code>i</code>, so the actual radius <code><var>ra<sub>i</sub></var></code> depends on the limit radii <code>m<sub>i-1</sub></code> and <code>m<sub>i</sub></code>:</p>

		<pre><var>ra<sub>i</sub></var> = <var>f</var>(R, <code>m<sub>i-1</sub></code>, <code>m<sub>i</sub></code>)</pre>

		<p>If the polygonal chain is open, then the edges arc <code>i</code> connects are edges <code>i</code> and <code>i+1</code>, so the actual radius <code><var>ra<sub>i</sub></var></code> depends on the limit radii <code>m<sub>i</sub></code> and <code>m<sub>i+1</sub></code>:</p>

		<pre><var>ra<sub>i</sub></var> = <var>f</var>(R, <code>m<sub>i</sub></code>, <code>m<sub>i+1</sub></code>)</pre>

		<p>This is illustrated by the following diagram:</p>

		<figure>
			<img src='images/fin_rad_diagr.svg' alt='' />
			<figcaption>diagram showing how getting the actual radii <code><var>ra</var></code> from the initial rounding radius set via the <code>r</code> attribute and from the limit radii <code>m</code> works in the two cases: <code>&lt;polygon&gt;</code> (top) vs. <code>&lt;polyline&gt;</code> (bottom)</figcaption>
		</figure>

		<p>In the unified case, we have that:</p>

		<pre><var>ra<sub>i</sub></var> = <var>f</var>(R, <code>m<sub>i+τ-1</sub></code>, <code>m<sub>i+τ</sub></code>)</pre>

		<p>So the JavaScript code that computes the actual radius we need to use for every arc is:</p>

		<pre>let ra = m.slice(0, na).map((c, i) => 
			Math.min(R, m[(i + τ - 1 + ne)%ne], m[i + τ]));</pre>

		<p><a href='https://codepen.io/thebabydino/pen/6b3e1f71cc8fad6f0f00e2dd42ca792e?editors=0011'>Test</a>.</p>

		<p>Alright, but just computing the actual radii doesn't really do anything, we need to update the <code>ρ</code> segments and the path data to use these newly computed radii instead of the initial radius <code>R</code> set via the <code>r</code> attribute:</p>

		<pre>let ρ = α.map((c, i) => ra[i]/Math.tan(.5*c));

let pd = 'M' + (τ ? v[0] + 'L' : '');

for(let i = 0; i < na; i++)
	pd += (i ? 'L' : '') + s[i] + 'A' + [ra[i], ra[i], 0, 0, f[i], ...e[i]];
	
pd += τ ? 'L' + v[n - 1] : 'z';</pre>

		<p>This solves the problem of the initial radius set via the <code>r</code> attribute being too big for some edges:</p>

		<p data-height="451" data-theme-id="0" data-slug-hash="4a2f85c8d835f7305bbab39317712752" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="[NMAR] round poly(gon|line) corners - fillet step #19" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/4a2f85c8d835f7305bbab39317712752/">[NMAR] round poly(gon|line) corners - fillet step #19</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

		<p>There's something very interesting that can be seen in the above demo - while the rounded shapes for the random polygon look different for different starting radii, in the case of the equilateral triangle, they're both circles. This is because, in the case of regular shapes, all edges and angles are equal. This means that all values in the <code>l</code> array (storing the edge lengths) are equal and all the values in the <code>α</code> (storing the angles of our polygonal chain) array are equal. Consequently, all values in the <code>m</code> array (the array of limit radii depending solely on these two sets of factors - edges and angles) are equal, so the shape we get for any given rounding radius greater than this common limit radius is always the same.</p>
		
		<p>At the limit, the end point of an arc coincides with the start point of the next arc and, since the actual radii are also equal and the central points of the circles are always inside the initial polygon shape in the case of a regular polygon, be it a convex regular one or a self-intersecting star one, then all these circles are all the same (as they have the same central point and the same radius). So we get to the conclusion that, in the case of any regular polygon, its rounding shape beyond the limit radius (that its edges and angles allow) is always the same circle that's tangent to all of its edges.</p>
		
		<p>But that's exactly what its <a href='http://mathworld.wolfram.com/Incircle.html'>incircle</a> is!</p>
		
		<p>So for any regular polygon, any rounding radius <code>R</code> (set via the <code>r</code> attribute) greater than the limit radius <code>m</code> always gives us a rounding shape that's identical to the inradius of the initial regular polygon. This is illustrated by the following demo:</p>
		
		<p data-height="400" data-theme-id="0" data-slug-hash="MbxQmJ" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="round regular poly corners" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/MbxQmJ/">round regular poly corners</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
		
		<p>Similarly, we always get the same shape for a rounding radius <code>R</code> greater than the limit radius <code>m</code> in the case of equilateral polygons where the sum of any two consecutive angles is always the same, which basically means equilateral polygons with an even number of vertices, all the even-numbered ones equal between them and all the odd-numbered ones equal between them (though the odd and the even not equal between them, as that would give us the particular case covered previously, that of a regular polygon). An simple example of this would be any rhombus.</p>

		<p>Now let's see how things look for random, pretty irregular polygonal chains:</p>

		<p data-height="525" data-theme-id="0" data-slug-hash="abe80e8697ebb911348856c86921d538" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="[NMAR] round poly(gon|line) corners - fillet step #20" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/abe80e8697ebb911348856c86921d538/">[NMAR] round poly(gon|line) corners - fillet step #20</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

		<p>Now everything looks nicely rounded even when the rounding radius set via the <code>r</code> attribute is too large!</p>

		<h2>copying the look of initial polygonal chains</h2>

		<p>Before we hide the original polygonal chains and leave just the path equivalents with rounded corners, we need to make sure they look the same way.</p>

		<p>The first thing that comes to mind here is to copy the attributes of the initial polygonal chain to the equivalent path. This takes care of everything that's been set via presentation attributes, via id, class, attribute selectors or via inline styles.</p>

		<p>I've been in doubt whether to do this for all attributes or exclude the <code>points</code> and <code>r</code> ones. I eventually decided not to exclude them because I didn't want to break styles in case there might be rule sets that use these attributes for the selectors - for example, something like this:</p>

		<pre>[points][r] { /* styles */ }</pre>

		<p>Also, while they have the downside of adding to the markup, their presence doesn't really do any harm.</p>

		<p>The code for copying the attributes looks as follows:</p>

		<pre>for(let i = 0; i < _poly.attributes.length; i++) {
	let attr = _poly.attributes[i];
	_path.setAttribute(attr.name, attr.value);
}</pre>
		<p>The following pen shows the result of adding the above code:</p>

		<p data-height="349" data-theme-id="0" data-slug-hash="8d1708c4c0f56823f2bc20b24409b54d" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="[NMAR] round poly(gon|line) corners - fillet step #21" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/8d1708c4c0f56823f2bc20b24409b54d/">[NMAR] round poly(gon|line) corners - fillet step #21</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

		<p>For the most part, things are fine. However, what copying all attributes doesn't cover is styles set using the <code>polygon</code> or <code>polyline</code> selectors. In the CSS of the above pen, we have as follows:</p>

		<pre>polygon, polyline { fill-opacity: .5 }

polygon { fill: #c7a0ee }

polyline { fill: #eec7a0 }</pre>

		<p>These styles don't get applied to the equivalent paths, as it is highlighted in the following illustration (the areas inside the equivalent path, but outside the initial polygonal line don't have a <code>fill</code>):</p>

		<figure>
			<img src='' alt=''/>
			<figcaption>ILLUSTRATIONNNNNNNNNNNNN</figcaption>
		</figure>

		<p>What we can do here is add some appropriate classes on the equivalent paths (let's say <code>fillet--c</code> for the equivalents of closed polygonal chains and <code>fillet--o</code> for the equivalents of open ones) and also add these classes to the above selector lists.</p>

		<p>Adding these classes to the equivalent paths is something we do for each such path after copying the attributes from the original polygonal chains:</p>

		<pre>_path.classList.add(`fillet--${τ ? 'o' : 'c'}`)</pre>

		<p>However, adding them wherever we have element selectors is something we do only do once, right at the beginning, before rounding any polygonal chain.</p>

		<p>In our case, the result we want is the following:</p>

		<pre>polygon, polyline, .fillet--c, .fillet--o { fill-opacity: .5 }

polygon, .fillet--c { fill: #c7a0ee }

polyline, .fillet--o { fill: #eec7a0 }</pre>

		<p>In order to do this, we need to scan the selector text for every CSS style rule in every stylesheet of our document.</p>

		<pre></pre>

		<h2>final words</h2>
	</body>
</html>