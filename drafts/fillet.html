<!DOCTYPE html>
<html lang='en'>
	<head>
		<meta charset='UTF-8' />
		<link rel='stylesheet' href='style.css' />
		<title>behind fillet.js - round poly(gon|line) corners</title>
	</head>
	<body>
		<h1>behind fillet.js - round poly(gon|line) corners</h1>

		<p>I've recently felt frustrated at the lack of an option to round the corners of a <code>&lt;polygon&gt;</code> element by simply specifying a rounding radius (<code>r</code>) attribute. After all, the <code>&lt;rect&gt;</code> element gives us the option of specifying rounding radii along the <code><var>x</var></code> and <code><var>y</var></code> axes via the <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rx'><code>rx</code></a> and <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ry'><code>ry</code></a> attributes.</p>

		<p>I've learned that it's been proposed and got asked if I could draft an algorithm for getting the equivalent <code>&lt;path&gt;</code> data (<code>d</code>) attribute from the <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/points'><code>points</code></a> and <code>r</code> attribute specified for the initial <code>&lt;polygon&gt;</code>. I've never done this before, had no idea how to do it, what to begin with, so I'd thought I'd have a more clear idea once I've coded some kind of JavaScript polyfill.</p>
		
		<p>Well, here it is - <code>fillet.js</code>! It's a script that rounds the corners of any inline <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code> elements that have a finite, positive rounding radius attribute (<code>r</code>) specified. All we need to do is include the script at the end of the page and... bam! Whenever we specify a valid rounding radius attribute <code>r</code> for a <code>&lt;polygon&gt;</code> or <code>&lt;polyline&gt;</code>, it magically gets rounded corners using that rounding radius or, if the given rounding radius is too big, the maximum rounding radius possible.</p>
		
		<p>This article is going to walk you through the thought process behind the code and show you how <code>fillet.js</code> was built - step by step. So let's get started!</p>
		
		<h2>picking test elements</h2>
		
		<p>For testing our code at every step, we pick two distinct <code>&lt;polygon&gt;</code> elements and two <code>&lt;polyline&gt;</code> elements with the same <code>points</code> attributes as the <code>&lt;polygon&gt;</code> elements.</p>
		
		<p>The first <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code> have the minimum number of coordinate pairs needed to create a polygonal shape (closed in the case of the <code>&lt;polygon&gt;</code> and open in the case of the <code>&lt;polyline&gt;</code>) - three. This is so that we make it easier for ourselves to check computations.</p>
		
		<p>For the first closed polygonal chain, we have the following code:</p>
		
		<pre>&lt;svg viewbox='-50 -50 100 100'>
	&lt;polygon points='50,0 -25,-43.3 -25,43.3' r='10'/>
&lt;/svg></pre>
		
		<p>If we want an open polygonal chain, then we replace <code>polygon</code> with <code>polyline</code> in the code above.</p>
		
		<p>The coordinates listed in the <code>points</code> attribute describe the vertices of an an equilateral triangle. Three vertices, three sets of coordinates, all edges equal, equal angles, all three <code>60°</code> ones. Furthermore, the first vertex (the one at <code>50,0</code>) is on the <code><var>x</var></code> axis, so its <code><var>y</var></code> coordinate is <code>0</code>. All chosen this way just to make our life easier when checking whether our code works correctly or not. For example, at some step, we may need to compute the angles between edges and, we know that, in this particular case, we should always get <code>60°</code> so, if that's not what our code outputs at that step, then there's something wrong with it.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_ini_test_reg_min.svg' alt='first two polygonal chains we use for testing: the vertices are those of an equilateral triangle, first one of the being on the x axis'/>
			<figcaption>first two polygonal chains we use for testing: the vertices are those of an equilateral triangle, first one of the being on the <code><var>x</var></code> axis</figcaption>
		</figure>
		
		<p>The other two polygonal chains use a completely random list of coordinates for their <code>points</code> attributes. This is to give us a sense of how things work outside the particular case because certain things may be valid for the particular case, but not for the general case and we shouldn't lose sight of that either.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_ini_test_rand_min.svg' alt='the other two polygonal chains we use for testing are completely random'/>
			<figcaption>the other two polygonal chains we use for testing are completely random; the dashed lines denote the possibility of more vertices being in between those they connect</figcaption>
		</figure>
		
		<p>For these elements, we've also set an <code>r</code> attribute - this is the rounding radius. It doesn't do anything at this point, but we'll soon start writing the JavaScript code which fixes that. The value is completely arbitrary, we took it to be <code>10</code> here because it's a nice round number (it's easier to multiply or divide by <code>10</code> than it is by, let's say, <code>7.8</code>) and it's also big enough relative to their sizes for the rounding such a radius produces to be noticeable.</p>
		
		<h2>vertex, edge and corner (angle) numbering</h2>
		
		<p>Before we sink our teeth into code, let's make sure a few basic concepts are clear.</p>
		
		<p>If we have a <code>points</code> attribute with <code>n</code> pairs of coordinates, then our polygonal chain, whether it's closed (<code>&lt;polygon&gt;</code>) or open (<code>&lt;polyline&gt;</code>) has <code>n</code> vertices: <code>0</code>, <code>1</code>, ... <code>n-1</code>.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_nv_min.svg' alt='if the points attribute has n pairs of coordinates, then our polygonal chain (closed or open, same thing) also has n vertices'/>
			<figcaption>if the <code>points</code> attribute has <code>n</code> pairs of coordinates, then our polygonal chain (closed or open, doesn't matter) also has <code>n</code> vertices</figcaption>
		</figure>
		
		<p>In the <code>&lt;polygon&gt;</code> case, we also have <code>n</code> edges. However, in the <code>&lt;polyline&gt;</code> case, we don't connect the last vertex (<code>n-1</code>) to the first one (<code>0</code>) anymore, so we have one edge less - that's <code>n-1</code> edges. In both cases, we take edge <code>0</code> to be the one between vertex <code>0</code> and vertex <code>1</code>, edge <code>1</code> between vertices <code>1</code> and <code>2</code> and so on... <strong>in general, edge <code>i</code> is between vertices <code>i</code> and <code>i+1</code></strong>, where <code>i</code> can be any natural number smaller than the number of edges.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_ne_min.svg' alt='if the points attribute has n pairs of coordinates, then our polygonal chain has n edges if it is closed and n-1 edges if it is open; in general, edge i is between vertices i and i+1 in both cases'/>
			<figcaption>if the <code>points</code> attribute has <code>n</code> pairs of coordinates, then our polygonal chain has <code>n</code> edges if it's closed and <code>n-1</code> edges if it's open; in general, edge <code>i</code> is between vertices <code>i</code> and <code>i+1</code> in both cases</figcaption>
		</figure>
		
		<p class='note'>In the <code>&lt;polygon&gt;</code> case, vertex <code>i+1</code> is actually vertex <code>(i+1)%n</code> - that's what's we're going to use in the JavaScript code, but, for now, we're lazy and we just want to write less.</p>
		
		<p>This means that, compared to a <code>&lt;polygon&gt;</code>, a <code>&lt;polyline&gt;</code> with the same <code>points</code> attribute is missing the polygon's last edge (<code>n-1</code>).</p>
		
		<p>Now let's move on to corners (angles). These are formed by two consecutive edges meeting at a vertex. In the <code>&lt;polygon&gt;</code> case, we have a corner (angle) at each vertex - that's <code>n</code> corners (angles). In the <code>&lt;polygon&gt;</code> case however, we don't have two edges meeting at the first (<code>0</code>) and last (<code>n-1</code>) vertices - those are endpoints, we have no corners (angles) there. This makes the number of corners (angles) equal to <code>n-2</code> in this situation.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_na_min.svg' alt='if the points attribute has n pairs of coordinates, then our polygonal chain has n angles if it is closed and n-2 angles if it is open'/>
			<figcaption>if the <code>points</code> attribute has <code>n</code> pairs of coordinates, then our polygonal chain has <code>n</code> corners (angles) if it's closed and <code>n-2</code> corners (angles) if it's open; in general, corner (angle) <code>i</code> is between edges <code>i-1</code> and <code>i</code> in the <code>&lt;polygon&gt;</code> case and between edges <code>i</code> and <code>i+1</code> in the <code>&lt;polyline&gt;</code> case</figcaption>
		</figure>
		
		<p>In the <code>&lt;polygon&gt;</code> case, the first corner (<code>0</code>) is formed where edges <code>n-1</code> and <code>0</code> meet at vertex <code>0</code>, second corner (<code>1</code>) is formed where  edges <code>0</code> and <code>1</code> meet at vertex <code>1</code> and, in general, corner <code>i</code> is formed where edges <code>i-1</code> and <code>i</code> meet at vertex <code>i</code>. While in the <code>&lt;polyline&gt;</code> case, the first corner (<code>0</code>) is formed where edges <code>0</code> and <code>1</code> meet at vertex <code>1</code> and, in general, corner <code>i</code> is formed where edges <code>i</code> and <code>i+1</code> meet at vertex <code>i+1</code>, where <code>i</code> can be any natural number smaller than the number of corners (<code>n-2</code>).</p>
		
		<p class='note'>Again, by <code>i-1</code>, we actually mean <code>(i+n-1)%n</code> and by <code>i+1</code> we actually mean <code>(i+1)%n</code> (though it's something we only care about if the polygonal chain is closed).</p>
		
		<p>Let's see what this means in the case of our first two polygonal chains. For the closed chain, we have <code>3</code> vertices, <code>3</code> edges and <code>3</code> corners (angles). For the open chain, we have <code>3</code> vertices, <code>2</code> edges (<code>3-1</code>) and <code>1</code> angle (<code>3-2</code>).</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_n_reg_min.svg' alt='numbering vertices (dark blue), edges (light blue) and angles (purple) for a polygonal chain (closed on the left and open on the right) whose vertex coordinates describe an equilateral triangle'/>
			<figcaption>numbering vertices (dark blue), edges (light blue) and angles (purple) for a polygonal chain (closed on the left and open on the right) whose vertex coordinates describe an equilateral triangle</figcaption>
		</figure>
		
		<p>This is important to understand because some of the variables we have to deal with with are vertex-related (for example, an array of vertex coordinates), which means they're arrays of length <code>n</code> in both cases. Others are edge-related (for example, an array of edge lengths or an array of edge slopes), which means they're arrays of length <code>n</code> in the <code>&lt;polygon&gt;</code> case and of length <code>n-1</code> in the <code>&lt;polyline&gt;</code> case. Others are corner-related (for example, an array of polygonal chain angles or an array of start or end points of each rounding arc), which means they're arrays of length <code>n</code> in the <code>&lt;polygon&gt;</code> case and of length <code>n-2</code> in the <code>&lt;polyline&gt;</code> case.</p>
		
		<h2>the start code</h2>
		
		<p>Now let's go to the JavaScript part. We begin by creating a <code>fillet(_poly)</code> function, which we call for every element that has both a <code>points</code> attribute (because the only two SVG elements that need it are <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code>) and an <code>r</code> attribute (because we only trigger corner rounding if we have a rounding radius specified):</p>

		<pre>function fillet(_poly) {};

const _P = document.querySelectorAll('[points][r]'), 
	NP = _P.length;

for(let i = 0; i &lt; NP; i++)
	fillet(_P[i]);</pre>
		
		<p>Our function doesn't yet do anything, so let's start working on that.</p>
		
		<h2>checking rounding radius validity</h2>
		
		<p>We read the value of the <code>r</code> attribute, <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators#Unary_plus'>convert</a> it to a number, then we check that the value we got is a finite, positive (<code>&gt; 0</code>) number. Otherwise, we exit the function.</p>

		<pre>const R = +_poly.getAttribute('r');

if(!isFinite(R) || R &lt;= 0) return;</pre>
		
		<p>In order to <a href='https://codepen.io/thebabydino/pen/393035a0796efb509ec4ed2afb866728?editors=1011'>test</a> this code, we also try giving the <code>r</code> attribute invalid values.</p>
		
		<h2>extracting vertex coordinates and checking their validity</h2>
		
		<p>Next, we extract the vertex coordinates from the <code>points</code> attribute, checking that they're at least <code>3</code> sets of coordinates, the minimum number to create a polygon (because a polygon has at least 3 vertices, in which case it's a triangle). Now we've written nice and clean <code>points</code> attributes for our test polygons and polylines, which makes them easy to split into sets of coordinates. However, differently formatted and messier versions display the exact same result, SVG is pretty forgiving here.</p>
		
		<p>All of the following also result in the exact same <code>&lt;polygon&gt;</code> or <code>&lt;polyline&gt;</code> (note the different comma and space placement and the fact that one even has an extra number at the end):</p>

		<pre>'50,0 -25,-43.3 -25,43.3'
'50 0 -25 -43.3 -25 43.3'
'50 0,-25 -43.3,-25 43.3'
'50 0 -25,-43.3 -25 43.3'
'50 0,-25 -43.3 -25,43.3'
'50 0,-25 -43.3 -25,43.3 17'
'50, 0 -25, -43.3 -25, 43.3'
'50,0 
-25,-43.3 
-25,43.3' 
'50 ,   0 -25 , -43.3        -25 , 43.3'</pre>

		<p>So, after reading the value of the <code>points</code> attribute, we need to make sure we catch all these possibilities with the regular expression we use to <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split'><code>split()</code></a> the string we get and then, since all the coordinate values are still strings at this point, we convert them to numbers:</p>

		<pre>let v = _poly.getAttribute('points')
	.split(/\s*,\s*|\s+/g)
	.map(c => +c);</pre>

		<p>This makes sure we get the same array if we have the same coordinates, no matter how the <code>points</code> attribute may have been formatted, as it can be seen in <a href='https://codepen.io/thebabydino/pen/d91ca4e8bcabb2962da6e71ba253ac33?editors=1011'>this Pen</a> (we get something like <code>[x<sub>0</sub>, y<sub>0</sub>, x<sub>1</sub>, y<sub>1</sub>, ...]</code>).</p>

		<p>Now we check if we have the minimum number of coordinates needed to form a polygon. If not, we exit the function.</p>

		<pre>let n = v.length;
if(.5*n &lt; 3) return;
n -= n%2;</pre>

		<p>After that, we check that all useful coordinates are finite numbers. If not, we exit the function, otherwise we compact the 1D array of coordinates into a 2D array of <code>x,y</code> pairs of coordinates (so basically, we go from something like <code>[x<sub>0</sub>, y<sub>0</sub>, x<sub>1</sub>, y<sub>1</sub>, ...]</code> to something like <code>[[x<sub>0</sub>, y<sub>0</sub>], [x<sub>1</sub>, y<sub>1</sub>], ...]</code>) using <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce'><code>reduce()</code></a>.</p>

		<pre>for(let i = 0; i &lt; n; i++)
	if(!isFinite(v[i])) return;

// a, c, i = accumulator, current item, current index
v = v.reduce((a, c, i) => i%2 ? a.concat([[v[i - 1], c]]) : a, []);

n = v.length;</pre>

		<p><a href='https://codepen.io/thebabydino/pen/4b263549df6413cec17ab3cec4f23619?editors=1011'>This Pen</a> tests that the above code works as intended.</p>
		
		<h2>getting the type of shape</h2>
		
		<p>So far, it didn't matter whether our shape is a <code>&lt;polygon&gt;</code> or a <code>&lt;polyline&gt;</code> because we've only dealt with invariant things (the polygonal chain itself <code>_poly</code>, its rounding radius <code>R</code>) or with vertex-related ones (the array of vertex coordinates <code>v</code>).</p>
		
		<p>But things are about to change, so we need to get the type of polygonal shape we're dealing with:</p>
		
		<pre>const T = +(_poly.localName !== 'polygon');</pre>
		
		<p><code>T</code> is <code>0</code> for a <code>&lt;polygon&gt;</code> element and <code>1</code> for a <code>&lt;polyline&gt;</code>, as it can be tested <a href='https://codepen.io/thebabydino/pen/4b6a361c302c1db1ab4b8bc69c127824?editors=1011'>here</a>.</p>
		
		<h2>checking for collinearity and eliminating unneeded vertices</h2>

		<p>We're doing one more check here and that's to see that no three consecutive points are <a href='http://mathworld.wolfram.com/Collinear.html'>collinear</a>. If that happens to be the case, we remove the one in the middle (the second of the three) because we don't really need it - with or without it, our shape is the same. The illustration below shows this:</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_collin_mid_reg_min.svg' alt='1, 2 and 3 are collinear; 2 is not a real vertex, we can safely remove it'/>
			<figcaption><code>1</code>, <code>2</code> and <code>3</code> are collinear; <code>2</code> isn't a real vertex, we can safely remove it</figcaption>
		</figure>
		
		<p>Points <code>1</code>, <code>2</code> and <code>3</code> are collinear. Point <code>2</code> isn't a real vertex, just a point on the segment between the previous (<code>1</code>) and the next (<code>3</code>) points. Removing it (and shifting the indices of the points that come after it) doesn't alter our shape, but reduces or code and makes our life easier.</p>
			
		<p>If removing a vertex happens to leave us with less than <code>3</code> vertices, then we exit the function.</p>
		
		<p>Whether we have a closed or an open polygonal chain, we need to perform this check for every possible group of three consecutive points.</p>
		
		<p>In the <code>&lt;polyline&gt;</code> case, these groups are:</p>
		
		<pre>0, 1, 2
1, 2, 3
...
i-1, i, i+1
...
n-3, n-2, n-1</pre>
		
		<p>The general form of these groups is <code>i-1, i, i+1</code>, where <code>1 &le; i &lt; n-1</code>.</p>
		
		<p>In the <code>&lt;polygon&gt;</code> case however, the list of points is cyclic. This means that the first point has a previous one (it's the last) and the last point has a next one (it's the first). So in this case, our groups are:</p>
		
		<pre><strong>n-1, 0, 1</strong>
0, 1, 2
1, 2, 3
...
i-1, i, i+1
...
n-3, n-2, n-1
<strong>n-2, n-1, 0</strong></pre>
		
		<p>The general form of these groups is pretty much the same as before, <code>(i-1+n)%n, i, (i+1)%n</code>, it's just that this time <code>0 &le; i &lt; n</code>.</p>
		
		<p>The geometric interpretation of this is that, in the <code>&lt;polyline&gt;</code> case, adding a point that's collinear with the first and the last at the beginning (or at the end) of the list of points gives us a different shape from the initial one. In the <code>&lt;polygon&gt;</code> case, this doesn't happen, we still have the same shape. This is why such a point is safe to remove in the <code>&lt;polygon&gt;</code> case, but not in the <code>&lt;polyline&gt;</code> one (we'd lose an edge in this case).</p>
		
		<p>The following image illustrates this. The first row presents the <code>&lt;polygon&gt;</code> case, while the second one presents the <code>&lt;polyline&gt;</code> case. The first colums shows the initial shapes. The second one shows the result of adding a point collinear with the first and last at the beginning of the list of points. The third one shows the result of adding a point collinear with the first and last at the beginning of the list of points.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_collin_end_reg_min.svg' alt='adding a point that is collinear to the first and the last at the beginning or at the end in the <polygon> case (top row, same shape in all cases) vs. in the <polyline> case (bottom row, different shapes); first colum shows the initial polygonal chains, while others show the results of adding a point that is collinear to the first and the last at the beginning (column two) or at the end (column three)'/>
			<figcaption>adding a point that's collinear to the first and the last at the beginning or at the end in the <code>&lt;polygon&gt;</code> case (top row, same shape in all cases) vs. in the <code>&lt;polyline&gt;</code> case (bottom row, different shapes); first colum shows the initial polygonal chains, while others show the results of adding a point that's collinear to the first and the last at the beginning (column two) or at the end (column three)</figcaption>
		</figure>
		
		<p>In the <code>&lt;polygon&gt;</code> case, adding this extra point doesn't modify the shape. The newly added point isn't a new vertex and the segments that start from it aren't two distinct edges, just two parts of the same edge. In the <code>&lt;polyline&gt;</code> case however, the newly added point is a new vertex, even if it's on the same line with the initial endpoints. This is because the initial endpoints aren't connected and, due to the nature of the polyline, this point doesn't get connected to both, only to one of them.</p>
		
		<p>Now let's see what putting the collinearity check into code means. For points <code>i-1</code>, <code>i</code> and <code>i+1</code> to be collinear, we need to have:</p>
		
		<pre>(y<sub>i</sub> - y<sub>i-1</sub>)*(x<sub>i+1</sub> - x<sub>i</sub>) = 
(x<sub>i</sub> - x<sub>i-1</sub>)*(y<sub>i+1</sub> - y<sub>i</sub>)</pre>
		
		<p>Of course, we need to think that some computation errors might come into play, so we cannot test for strict equality. Instead, we test whether the absolute value of the difference between the two parts is smaller than a certain error threshold <code>ε</code>.</p>
		
		<pre>|(y<sub>i</sub> - y<sub>i-1</sub>)*(x<sub>i+1</sub> - x<sub>i</sub>) -
 (x<sub>i</sub> - x<sub>i-1</sub>)*(y<sub>i+1</sub> - y<sub>i</sub>)| &lt; ε</pre>
		
		<p>If this difference in absolute value is smaller than this error threshold <code>ε</code> (which we take to be <code>.1</code>), then we remove point <code>i</code> (more exactly, its vertex coordinates from the <code>v</code> array) and also update the value of the number of points <code>n</code> (which also means we have to recheck whether <code>n</code> is still at least <code>3</code> because, if it isn't, then we don't have enough points to draw a polygon anymore).</p>
		
		<p>As established before, we perform this check for every <code>i</code> in the <code>{0, 1, ... n-1}</code> set in the <code>&lt;polygon&gt;</code> case and for every <code>i</code> in the <code>{1, ... n-2}</code> set in the <code>&lt;polyline&gt;</code> case.</p>
		
		<p>This gives us the following JavaScript code:</p>
		
		<pre>for(let i = T; i &lt; n - T; i++) {
	let c = v[i] /* current vertex coords */, 
		prv = v[(i + n - 1)%n] /* previous */, 
		nxt = v[(i + 1)%n] /* next */;

	/*
	 * are previous, current and next 
	 * vertices collinear?
	 */
	if((c[1] - prv[1])*(nxt[0] - c[0]) -
		(c[0] - prv[0])*(nxt[1] - c[1]) &lt; .1) {
		/* remove current vertex */
		v.splice(i--, 1);
		/* do we still have enough vertices? */
		if(--n &lt; 3) return;
	}
}</pre>

		<p><a href='https://codepen.io/thebabydino/pen/fbf4429f30c242e31bf65dd680cfa93a?editors=1011'>This pen</a> checks that the above code works as intended.</p>
		
		<h2>recap of what we know so far</h2>
		
		<p>Now that we got edge cases out of the way, let's see what we have so far:</p>
		
		<ul>
			<li>the rounding radius <code>r</code>, which we've extracted from the <code>r</code> attribute</li>
			<li>the vertex coordinates (the <code>v</code> array) of the initial polygonal chain, which we've extracted from the <code>points</code> attribute</li>
			<li>the number (<code>n</code>) of vertices</li>
		</ul>
		
		<h2>how rounding corners works</h2>
		
		<p>A polygonal chain with rounded corners is equivalent to a path made up of straight line segments (one along each proper edge of the initial polygonal chain) and arcs (one replacing each corner of the initial polygonal chain).</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_path_equiv_rand_min.svg' alt=''/>
			<figcaption>equivalent paths for polygonal chains with rounded corners with the start and end points for each arc marked on the figure; note how in the <code>&lt;polygon&gt;</code> case, arc <code>i</code> is at vertex <code>i</code> (and we have <code>n</code> arcs in total), while in the <code>&lt;polyline&gt;</code> case, it's at vertex <code>i+1</code> (and we only have <code>n-2</code> arcs in total, as the first and last vertices are endpoints and we don't have arcs there)</figcaption>
		</figure>
		
		<p>This <code>&lt;path&gt;</code> element's data (<code>d</code>) attribute is made up of:</p>

		<ul>
			<li>a "move to" (<code>M</code>) command followed by the coordinates of the point where our path starts;
				<ul>
					<li>in the <code>&lt;polygon&gt;</code> case, this is the start point of the first arc (<code><var>S<sub>0</sub></var></code>), whose coordinates are <code><var>xs<sub>0</sub></var>,<var>ys<sub>0</sub></var></code> (still unknown at this point);
					</li>
					<li>in the <code>&lt;polyline&gt;</code> case, this is the first vertex of the initial <code>&lt;polyline&gt;</code> (<code><var>A<sub>0</sub></var></code>), whose coordinates are <code>x<sub>0</sub>,y<sub>0</sub></code> (which we already have);</li>
				</ul>
			</li>
			<li>an "arc to" (<code>A</code>) command for every <code>i</code>-th arc (where <code>0 &le; i &lt; n</code> in the <code>&lt;polygon&gt;</code> case and <code>0 &le; i &lt; n-2</code> in the <code>&lt;polyline&gt;</code> case); this draws the arc between its start point (<code><var>S<sub>i</sub></var></code>) and its end point <code><var>E<sub>i</sub></var></code>);</li>
			<li>a "line to" (<code>L</code>) command for every <code>i</code>-th segment where <code>0 &le; i &lt; n-1</code>, followed by the coordinates point where this line segment ends;
				<ul>
					<li>in the <code>&lt;polygon&gt;</code> case, this is the start point of the next arc (<code><var>S<sub>i+1</sub></var></code>), whose coordinates are <code><var>xs<sub>i+1</var></sub>,<var>ys<sub>i+1</var></sub></code>; also, this line segment starts from the end point of the arc we've just drawn (<code><var>E<sub>i</sub></var></code>, of coordinates <code><var>xe<sub>i</var></sub>,<var>ye<sub>i</var></sub></code>);</li>
					<li>in the <code>&lt;polyline&gt;</code> case, this is either the start point of the next arc (<code><var>S<sub>i+1</sub></var></code>), whose coordinates are <code><var>xs<sub>i+1</var></sub>,<var>ys<sub>i+1</var></sub></code> (still unknown at this point) or the last vertex of the initial <code>&lt;polyline&gt;</code> (<code><var>A<sub>n-1</sub></var></code>), whose coordinates are <code>x<sub>n-1</sub>,y<sub>n-1</sub></code> (which we already have); also, this line segment starts either from the first vertex of the initial <code>&lt;polyline&gt;</code> (<code><var>A<sub>0</sub></var></code>), whose coordinates are <code>x<sub>0</sub>,y<sub>0</sub></code> (which we already have) or from the end point of the arc we've just drawn (<code><var>E<sub>i</sub></var></code>), of coordinates <code><var>xe<sub>i</var></sub>,<var>ye<sub>i</var></sub></code> (still unknown at this point);</li>
				</ul>
			</li>
			<li><strong>only in the <code>&lt;polygon&gt;</code> case</strong>, a "close path" (<code>z</code>) command at the end which connects the end point of the last arc (<code><var>E<sub>n-1</sub></var></code> of coordinates <code><var>xe<sub>n-1</sub></var>,<var>ye<sub>n-1</sub></var></code>) to the start point of our path (also the start point of the first arc <code><var>S<sub>0</sub></var></code>);</li>
		</ul>
		
		<h2>the "arc to" (<code>A</code>) command</h2>
		
		<p>Let's take a closer look at the components of an "arc to" command. We have the following:</p>

		<ul>
			<li>the radius of this arc along the <code><var>x</var></code> axis of its system of coordinates - this is equal to the rounding radius <code>r</code></li>
			<li>the radius of this arc along the <code><var>y</var></code> axis of its system of coordinates - this is also equal to the rounding radius <code>r</code></li>
			<li>the rotation of its system of coordinates - this doesn't matter in our case since the radii along the two 2D dimensions (<code>x</code> and <code>y</code>) are equal, so we take it to be <code>0</code> to keep things as simple as possible</li>
			<li>the large arc flag - this is <code>0</code> in our case since we always take the small arc at a vertex (the one inside the small angle, the one under <code>180°</code></li>
			<li>the sweep flag <code><var>f<sub>i</sub></var></code> - this is <code>1</code> if the arc goes clockwise between its start and its end point and <code>0</code> otherwise; it's something we need to compute for each arc</li>
			<li>the <code><var>x</var></code> coordinate of the arc's end point - this is <code><var>xe<sub>i</sub></var></code> for the generic <code>i</code>-th arc</li>
			<li>the <code><var>y</var></code> coordinate of the arc's end point - this is <code><var>ye<sub>i</sub></var></code> for the generic <code>i</code>-th arc</li>
		</ul>
		
		<h2>path data structure</h2>
		
		<p>Knowing all this, our path data is going to look something like this <code>&lt;polygon&gt;</code> case:</p>

		<pre>M <var>xs<sub>0</sub></var>, <var>ys<sub>0</sub></var>
A r, r, 0, 0, <var>f<sub>0</sub></var>, <var>xe<sub>0</sub></var>, <var>ye<sub>0</sub></var>
L <var>xs<sub>1</sub></var>, <var>ys<sub>1</sub></var>
A r, r, 0, 0, <var>f<sub>1</sub></var>, <var>xe<sub>1</sub></var>, <var>ye<sub>1</sub></var>
...
L <var>xs<sub>i</sub></var>, <var>ys<sub>i</sub></var>
A r, r, 0, 0, <var>f<sub>i</sub></var>, <var>xe<sub>i</sub></var>, <var>ye<sub>i</sub></var>
...
L <var>xs<sub>n-2</sub></var>, <var>ys<sub>n-2</sub></var>
A r, r, 0, 0, <var>f<sub>n-2</sub></var>, <var>xe<sub>n-2</sub></var>, <var>ye<sub>n-2</sub></var>
L <var>xs<sub>n-1</sub></var>, <var>ys<sub>n-1</sub></var>
A r, r, 0, 0, <var>f<sub>n-1</sub></var>, <var>xe<sub>n-1</sub></var>, <var>ye<sub>n-1</sub></var>
z</pre>
		
		<p>In the <code>&lt;polygon&gt;</code> case, things look a bit different:</p>
		
		<pre>M x<sub>0</sub>, y<sub>0</sub>
L <var>xs<sub>0</sub></var>, <var>ys<sub>0</sub></var>
A r, r, 0, 0, <var>f<sub>0</sub></var>, <var>xe<sub>0</sub></var>, <var>ye<sub>0</sub></var>
L <var>xs<sub>1</sub></var>, <var>ys<sub>1</sub></var>
A r, r, 0, 0, <var>f<sub>1</sub></var>, <var>xe<sub>1</sub></var>, <var>ye<sub>1</sub></var>
...
L <var>xs<sub>i</sub></var>, <var>ys<sub>i</sub></var>
A r, r, 0, 0, <var>f<sub>i</sub></var>, <var>xe<sub>i</sub></var>, <var>ye<sub>i</sub></var>
...
L <var>xs<sub>n-3</sub></var>, <var>ys<sub>n-3</sub></var>
A r, r, 0, 0, <var>f<sub>n-3</sub></var>, <var>xe<sub>n-3</sub></var>, <var>ye<sub>n-3</sub></var>
L x<sub>n-1</sub>, y<sub>n-1</sub></pre>
		
		<p>However, in the end, we still to get the same three things for each arc <code>i</code>, whether the number of arcs is <code>n</code> (closed polygonal chain) or <code>n-2</code> (open polygonal chain):</p>
		
		<ul>
			<li>whether it goes clockwise or not, which determines the value (<code>1</code> or <code>0</code>) for its sweep flag <code><var>f<sub>i</sub></var></code></li>
			<li>the coordinates <code><var>xs<sub>i</sub></var>,<var>ys<sub>i</sub></var></code> of its start point <code><var>S<sub>i</sub></var></code></li>
			<li>the coordinates <code><var>xe<sub>i</sub></var>,<var>ye<sub>i</sub></var></code> of its end point <code><var>E<sub>i</sub></var></code></li>
		</ul>
		
		<h2>getting the sweep flags</h2>
		
		<p>For the <code>i</code>-th arc, the value of the sweep flag <code><var>f<sub>i</sub></var></code> is determined by whether the arc goes clockwise (in which case it's <code>1</code>) or not (in which case it's <code>0</code>).</p>
		
		<p>We can get the direction of the arc replacing vertex <code>i</code> by <a href='https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon'>computing the following sum</a>:</p>
		
		<pre>  x<sub>i-1</sub>y<sub>i</sub> + x<sub>i</sub>y<sub>i+1</sub> + x<sub>i+1</sub>y<sub>i-1</sub>
- y<sub>i-1</sub>x<sub>i</sub> - y<sub>i</sub>x<sub>i+1</sub> - y<sub>i+1</sub>x<sub>i-1</sub></pre>
		
		<p>If this sum is positive, then the arc goes in the clockwise direction and the sweep flag for the arc we replace vertex <code>i</code> with is <code>1</code>. If it's negative, then the arc goes counterclockwise and the sweep flag is <code>0</code>. But what if it's exactly <code>0</code>? Well, that cannot happen, as it would mean the three points are collinear and we've already taken care of that situation.</p>

		<p>If the sum is positive, then the sign of the sum is <code>+</code> (the value of the <a href='https://en.wikipedia.org/wiki/Sign_function'>sign function</a> is <code>1</code>) and the corresponding sweep flag is <code>1</code>. If the sum is negative, then the sign of the sum is <code>-</code> (the value of the sign function is <code>-1</code>) and corresponding sweep flag is <code>0</code>.</p>
		
		<p>This helps us extract a formula for <code><var>f<sub>i</sub></var></code>:</p>

		<pre><var>f<sub>i</sub></var> = .5*(sgn(Σ<sub>i</sub>) + 1)</pre>
		
		<p>We can check that this works for both a positive sum (<code>.5*(1 + 1) = .5*2 = 1</code>) as well as for a negative one (<code>.5*(-1 + 1) = .5*0 = 0</code>).</p>
		
		<p>A very important thing to keep in mind is that that arc <code>i</code> replaces vertex <code>i</code> only for a closed polygonal chain. For an open one, it replaces vertex <code>i+1</code>. This is because the array of sweep flags (like all other variables that define an arc, such as the coordinates of its endpoints) is corner-related - we have a sweep flag for each arc, but we have no arcs at the vertices where we don't have corners (the endpoints of a <code>&lt;polyline&gt;</code>)</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_sweep_f_arc_min.svg' alt='the rounding arcs highlighted for the two random polygonal chains: closed (left) vs. open (right)'/>
			<figcaption>the rounding arcs highlighted for the two random polygonal chains: closed (left) vs. open (right)</figcaption>
		</figure>
		
		<p>This means that, in the <code>&lt;polygon&gt;</code> case, the value of the sweep flag <code><var>f<sub>i</sub></var></code> depends on the coordinates of vertices <code>i-1</code>, <code>i</code> (the one it replaces) and <code>i+1</code>:</p>
		
		<pre><var>f<sub>i</sub></var> = fn(v<sub>i-1</sub>, v<sub>i</sub>, v<sub>i+1</sub>)</pre>
		
		<p>In the <code>&lt;polyline&gt;</code> case, the value of the sweep flag <code><var>f<sub>i</sub></var></code> depends on the coordinates of vertices <code>i</code>, <code>i+1</code> (the one it replaces) and <code>i+2</code>:</p>
		
		<pre><var>f<sub>i</sub></var> = fn(v<sub>i</sub>, v<sub>i+1</sub>, v<sub>i+2</sub>)</pre>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_sweep_f_diagr_min.svg' alt=''/>
			<figcaption>diagram showing how getting sweep flags from vertex coordinates works in the two cases: <code>&lt;polygon&gt;</code> (top) vs. <code>&lt;polyline&gt;</code> (bottom)</figcaption>
		</figure>
		
		<p>If <code>T</code> is the type of polygonal chain (<code>0</code> when closed vs. <code>1</code> when open), then the two can be unified:</p>
		
		<pre><var>f<sub>i</sub></var> = fn(v<sub>i-1+T</sub>, v<sub>i+T</sub>, v<sub>i+1+T</sub>)</pre>
		
		<p>In the <code>&lt;polygon&gt;</code> case, both the index of the current arc and that of the vertex it's replacing going from <code>0</code> all the way through <code>n-1</code> (<code>0 &le; i &lt; n</code>). In the <code>&lt;polygon&gt;</code> case, the index of the current arc goes from <code>0</code> through <code>n-3</code> (<code>0 &le; i &lt; n-2</code>), while that of the index it replaces goes from <code>1</code> through <code>n-2</code> (<code>1 &le; i &lt; n-1</code>).</p>
		
		<p>In the unified case, the index of the current arc goes from <code>0</code> through <code>n-1-2*T</code> (<code>0 &le; i &lt; n-2*T</code>), while that of the index it replaces goes from <code>T</code> through <code>n-1-T</code> (<code>T &le; i &lt; n-T</code>).</p>
		
		<p>Now let's code this! What we do here is <a href='https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map'><code>map()</code></a> the 2D array of vertex coordinates to a 1D array of flags:</p>
		
		<pre>let f = v.slice(T, n - T).map((c, i) => {
	let prv = v[(i + n - 1 + T)%n] /* previous */, 
		nxt = v[(i + 1 + T)%n] /* next */,
		Σ /* sum */;

	Σ = prv[0]*c[1] + c[0]*nxt[1] + nxt[0]*prv[1]
		- prv[1]*c[0] - c[1]*nxt[0] - nxt[1]*prv[0];

	return .5*(Math.sign(Σ) + 1);
});</pre>
		
		<p><a href='https://codepen.io/thebabydino/pen/d71cfc5580d99d1ccbbd67fcf47ee7ae?editors=0011'>This Pen</a> checks that the above bit of JavaScript works as it should.</p>
		
		<h2>getting the start and end points of the arcs</h2>
		
		<h3>getting coordinates for random point in the plane</h3>
		
		<p>Let's take a random point <code><var>P</var></code>, whose coordinates <code><var>xp</var>,<var>yp</var></code> we need to compute. We can consider this point to be on a circle of radius <code>r</code>. Its <code><var>xp</var>,<var>yp</var></code> coordinates depend on the radius of the circle and on where it is on the circle. The measure of where it is on the circle is the angle <code>θ</code> between the radial line <code><var>OP</var></code> and the horizontal (the <code><var>Ox</var></code> axis). The following interactive demo illustrates this (drag point <code><var>P</var></code> to see how its coordinates change as the circle radius and the angle of the radial line change):</p>
		
		<p data-height="620" data-theme-id="0" data-slug-hash="KNxXZJ" data-default-tab="result" data-user="thebabydino" data-embed-version="2" data-pen-title="position of point in a plane (drag point)" class="codepen">See the Pen <a href="https://codepen.io/thebabydino/pen/KNxXZJ/">position of point in a plane (drag point)</a> by Ana Tudor (<a href="http://codepen.io/thebabydino">@thebabydino</a>) on <a href="http://codepen.io">CodePen</a>.</p>
		<script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
		
		<p>Consider the following particular case:</p>

		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_pt_coords_pcase_min.svg' alt='particular case of a point in a plane'/>
			<figcaption>particular case of a point in a plane</figcaption>
		</figure>

		<p>The <code><var>Q</var></code> and <code><var>R</var></code> points are the projections of our point <code><var>P</var></code> onto the axes of our system of coordinates. This means that <code><var>PQ</var></code> and <code><var>PR</var></code> are perpendicular onto the axes (the <code>∠<var>PQO</var></code> and <code>∠<var>PRO</var></code> angles are <code>90°</code> angles). It also means that the <code><var>OQ</var></code> and <code><var>PR</var></code> segments are equal to <code><var>xp</var></code> (which is the value of <code><var>P</var></code>'s <code><var>x</var></code> coordinate) and that the <code><var>OR</var></code> and <code><var>PQ</var></code> segments are equal to <code><var>yp</var></code> (which is the value of <code><var>P</var></code>'s <code><var>y</var></code> coordinate).</p>

		<p><code><var>PQO</var></code> is a right triangle (since the <code>∠<var>PQO</var></code> angle is a <code>90°</code> angle) where we know the hypotenuse <code><var>OP</var></code> (it's <code>r</code>, the radius of the circle <code><var>P</var></code>    is on) and the <code>∠<var>QOP</var></code> angle (it's <code>θ</code>).</p>

		<p>The cosine of the <code>∠<var>QOP</var></code> angle (<code>θ</code>) is the ratio between the adjacent <a href='https://en.wikipedia.org/wiki/Cathetus'>cathetus</a> <code><var>OQ</var></code> (<code><var>xp</var></code>) and the hypotenuse <code><var>OP</var></code> (<code>r</code>). This means we have <code>cos(θ) = <var>xp</var>/r</code> and, from here, we get that <code><var>xp</var> = r*cos(θ)</code>.</p>

		<p>Similarly, the sine of the same <code>∠<var>QOP</var></code> angle (<code>θ</code>) is the ratio between the opposing cathetus <code><var>PQ</var></code> (<code><var>yp</var></code>) and the hypotenuse <code><var>OP</var></code> (<code>r</code>). This means we have <code>sin(θ) = <var>yp</var>/r</code> and, from here, we get that <code><var>yp</var> = r*sin(θ)</code>.</p>

		<p>So the <code><var>xp</var>,<var>yp</var></code> coordinates of any point <code><var>P</var></code> on a circle around the origin are:</p>

		<pre><var>xp</var> = r*cos(θ)
<var>yp</var> = r*sin(θ)</pre>

		<p>Here, <code>r</code> is the radius of the circle and <code>θ</code> is the angle of the radial line connecting the origin to our point <code><var>P</var></code> with respect to the horizontal (both are known).</p>
		
		<p>But what about the case when this circle's central point doesn't coincide with the <code>0,0</code> point of the coordinate system? Well, in this case, we need to add up the coordinates of the circle's central point:</p>

		<pre><var>xp</var> = xo + r*cos(θ)
<var>yp</var> = yo + r*sin(θ)</pre>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_pt_coords_pcase_off_min.svg' alt='particular case of a point in a plane when the central point of the circle it is on is not at the (0,0) point of the coordinate system'/>
			<figcaption>particular case of a point in a plane when the central point of the circle it's on is not at the <code>0,0</code> point of the coordinate system</figcaption>
		</figure>
		
		<p>This is the situation we're actually interested in because what we do here is take the start and end points of our arcs as being on circles whose central points are the corner points of our initial polygonal chain.</p>
		
		<p>Let's consider first the start points:</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_s_pts_on_circ_base_min.svg' alt='start points of arcs relative to vertices of initial polygonal chain'/>
			<figcaption>start points of arcs relative to vertices of initial polygonal chain</figcaption>
		</figure>

		<p>So for arc <code>i</code>, the coordinates of its start points can be computed from the <code>x<sub>i+T</sub>,y<sub>i+T</sub></code> coordinates of the the polygonal chain vertex that's being replaced by this arc <code><var>A<sub>i+T</sub></var></code> (<code><var>A<sub>i</sub></var></code> in the <code>&lt;polygon&gt;</code> case when <code>T = 0</code> and <code><var>A<sub>i+1</sub></var></code> in the <code>&lt;polyline&gt;</code> case when <code>T = 1</code>), the radius <code><var>A<sub>i+T</sub>S<sub>i</sub></var></code> (<code><var>A<sub>i</sub>S<sub>i</sub></var></code> in the <code>&lt;polygon&gt;</code> case when <code>T = 0</code> and <code><var>A<sub>i+1</sub>S<sub>i</sub></var></code> in the <code>&lt;polyline&gt;</code> case when <code>T = 1</code>) of this circle and the angle of the radial segment <code><var>A<sub>i+T</sub>S<sub>i</sub></var></code> with respect to the horizontal. We already know all vertex coordinates, so what we still need to get are the <code><var>A<sub>i+T</sub>S<sub>i</sub></var></code> radii and the angles between the horizontal and these radial lines.</p>
		
		<h3>angles of radial segments with respect to the horizontal</h3>
		
		<p>If we also draw the angles on the previous figure, it looks like this:</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_01_a_fillet_s_pts_on_circ_meas_min.svg' alt='angles of radial segments with respect to the horizontal'/>
			<figcaption>angles of radial segments <code><var>A<sub>i+T</sub>S<sub>i</sub></var></code> with respect to the horizontal</figcaption>
		</figure>
				
		<p>Since the <code><var>S<sub>i</sub></var></code> points are on the <code><var>A<sub>i+T</sub>A<sub>i-1+T</sub></var></code> segments, the angles of the <code><var>A<sub>i+T</sub>S<sub>i</sub></var></code> radii with respect to the horizontal are the angles between the horizontal and these <code><var>A<sub>i+T</sub>A<sub>i-1+T</sub></var></code> segments (which are edges of our initial polygonal chain). This means that the array of <code><var>β</var></code> angles we need to get is an edge-related variable - we compute one angle for each edge of the polygonal chain, so we have one less angle computation to do in the <code>&lt;polyline&gt;</code> case (because we have one less edge in this situation).</p>
		
		
			
		<h3>circles, tangents, right triangles and congruence</h3>
		
		
	</body>
</html>