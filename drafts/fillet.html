<!DOCTYPE html>
<html lang='en'>
	<head>
		<meta charset='UTF-8' />
		<title>SVGrr</title>
		<link rel='stylesheet' href='styles/index.processed.css'>
	</head>
	<body>
		<h1>behind fillet.js - round poly(gon|line) corners</h1>

		<p>I've recently felt frustrated at the lack of an option to round the corners of a <code>&lt;polygon&gt;</code> element by simply specifying a rounding radius (<code>r</code>) attribute. After all, the <code>&lt;rect&gt;</code> element gives us the option of specifying rounding radii along the <code><var>x</var></code> and <code><var>y</var></code> axes via the <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/rx'><code>rx</code></a> and <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/ry'><code>ry</code></a> attributes.</p>

		<p>I've learned that it's been proposed and got asked if I could draft an algorithm for getting the equivalent <code>&lt;path&gt;</code> data (<code>d</code>) attribute from the <a href='https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/points'><code>points</code></a> and <code>r</code> attributes specified for the initial <code>&lt;polygon&gt;</code>. I've never done this before, had no idea how to do it, what to begin with, so I'd thought I'd have a more clear idea once I've coded some kind of JavaScript polyfill.</p>
		
		<p>Well, here it is - <code>fillet.js</code>! It's a script that rounds the corners of any inline <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code> elements that have a finite, positive rounding radius attribute (<code>r</code>) specified. All we need to do is include the script at the end of the page and... bam! Whenever we specify a valid rounding radius attribute <code>r</code> for a <code>&lt;polygon&gt;</code> or <code>&lt;polyline&gt;</code>, it magically gets rounded corners using that rounding radius or, if the given rounding radius is too big, the maximum rounding radius possible.</p>
		
		<p>This article is going to walk you through the thought process behind the code and show you how <code>fillet.js</code> was built - step by step. So let's get started!</p>
		
		<h2>picking test elements</h2>
		
		<p>For testing our code at every step, we pick two distinct <code>&lt;polygon&gt;</code> elements and two <code>&lt;polyline&gt;</code> elements with the same <code>points</code> attributes as the previously mentioned polygons.</p>
		
		<p>The first <code>&lt;polygon&gt;</code> and <code>&lt;polyline&gt;</code> have the minimum number of coordinate pairs needed to create a polygonal shape (closed in the case of the <code>&lt;polygon&gt;</code> and open in the case of the <code>&lt;polyline&gt;</code>) - three. This is so that we make it easier for ourselves to check computations.</p>
		
		<p>For the first closed polygonal chain, we have the following code:</p>
		
		<pre>&lt;svg viewbox='-50 -50 100 100'>
	&lt;polygon points='50,0 -25,-43.3 -25,43.3' r='10'/>
&lt;/svg></pre>
		
		<p>If we want an open polygonal chain, then we replace <code>polygon</code> with <code>polyline</code> in the code above.</p>
		
		<p>The coordinates listed in the <code>points</code> attribute describe the vertices of an an equilateral triangle. Three vertices, three sets of coordinates, all edges equal, equal angles, all three <code>60°</code> ones. Furthermore, the first vertex (the one at <code>50,0</code>) is on the <code><var>x</var></code> axis, so its <code><var>y</var></code> coordinate is <code>0</code>. All chosen this way just to make our life easier when checking whether our code works correctly or not. For example, at some step, we may need to compute the angles between edges and, we know that, in this particular case, we should always get <code>60°</code> so, if that's not what our code outputs at that step, then there's something wrong with it.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_02_a_svgrr_ini_test_reg_min.svg' alt='first two polygonal chains we use for testing: the vertices are those of an equilateral triangle, first one of the being on the x axis'/>
			<figcaption>first two polygonal chains we use for testing: the vertices are those of an equilateral triangle, first one of the being on the <code><var>x</var></code> axis</figcaption>
		</figure>
		
		<p>The other two polygonal chains use a completely random list of coordinates for their <code>points</code> attributes. This is to give us a sense of how things work outside the particular case because certain things may be valid for the particular case, but not for the general case and we shouldn't lose sight of that either.</p>
		
		<figure>
			<img src='https://s3-us-west-2.amazonaws.com/s.cdpn.io/2017/17_02_a_svgrr_ini_test_rnd_min.svg' alt='the other two polygonal chains we use for testing are completely random'/>
			<figcaption>the other two polygonal chains we use for testing are completely random; the dashed lines denote the possibility of more vertices being in between those they connect</figcaption>
		</figure>
		
		<p>For these elements, we've also set an <code>r</code> attribute - this is the rounding radius. It doesn't do anything at this point, but we'll soon start writing the JavaScript code which fixes that. The value is completely arbitrary, we took it to be <code>10</code> here because it's a nice round number (it's easier to multiply or divide by <code>10</code> than it is by, let's say, <code>7.8</code>) and it's also big enough relative to their sizes for the rounding it produces to be noticeable.</p>
		
		<h2>vertex, edge and corner (angle) numbering</h2>
		
		<p>Before we sink our teeth into code, let's make sure a few basic concepts are clear.</p>
		
		<p>If we have a <code>points</code> attribute with <code>n</code> pairs of coordinates, then our polygonal chain, whether it's closed (<code>&lt;polygon&gt;</code>) or open (<code>&lt;polyline&gt;</code>) has <code>n</code> vertices: <code>0</code>, <code>1</code>, ... <code>n-1</code>.</p>
	</body>
</html>